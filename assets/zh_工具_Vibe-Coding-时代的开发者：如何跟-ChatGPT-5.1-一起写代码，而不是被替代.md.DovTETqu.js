import{_ as i,c as l,o as n,a6 as e}from"./chunks/framework.BwtyjzPT.js";const u=JSON.parse('{"title":"Vibe Coding 时代的开发者：如何跟 ChatGPT 5.1 一起写代码，而不是被替代","description":"在 Vibe Coding 时代，ChatGPT 5.1 已经坐在你的工位上了。这篇文章聊的不是“会不会被 AI 替代”，而是：如何和 ChatGPT 5.1 一起写代码，让它加班，你下班。","frontmatter":{"title":"Vibe Coding 时代的开发者：如何跟 ChatGPT 5.1 一起写代码，而不是被替代","date":"2025-11-28T00:00:00.000Z","author":"PFinal南丞","category":"工具","tags":["ai coding","chatgpt 5.1","vibe coding","developer productivity","software engineering"],"description":"在 Vibe Coding 时代，ChatGPT 5.1 已经坐在你的工位上了。这篇文章聊的不是“会不会被 AI 替代”，而是：如何和 ChatGPT 5.1 一起写代码，让它加班，你下班。","keywords":["vibe coding","chatgpt 5.1 coding","ai 写代码 实战","开发者 会不会被 ai 替代","ai 编程 工作流","chatgpt 辅助 编程","ai 代码 质量","ai 调试 难点","开发者 职业 焦虑 ai"],"head":[["link",{"rel":"canonical","href":"https://friday-go.icu/zh/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代"}],["link",{"rel":"alternate","hreflang":"zh-CN","href":"https://friday-go.icu/zh/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代"}],["link",{"rel":"alternate","hreflang":"en","href":"https://friday-go.icu/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代"}],["link",{"rel":"alternate","hreflang":"x-default","href":"https://friday-go.icu/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代"}],["meta",{"name":"keywords","content":"vibe coding,chatgpt 5.1 coding,ai 写代码 实战,开发者 会不会被 ai 替代,ai 编程 工作流,chatgpt 辅助 编程,ai 代码 质量,ai 调试 难点,开发者 职业 焦虑 ai, PFinalClub, Golang tutorial, Go backend development, Go microservices, PHP, Python, 技术博客, Tech Blog"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"TechArticle\\",\\"headline\\":\\"Vibe Coding 时代的开发者：如何跟 ChatGPT 5.1 一起写代码，而不是被替代\\",\\"url\\":\\"https://friday-go.icu/zh/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代\\",\\"datePublished\\":\\"2025-11-28T00:00:00.000Z\\",\\"dateModified\\":1764638248000,\\"author\\":{\\"@type\\":\\"Person\\",\\"name\\":\\"PFinal南丞\\",\\"url\\":\\"https://friday-go.icu/about\\"},\\"publisher\\":{\\"@type\\":\\"Organization\\",\\"name\\":\\"PFinalClub\\",\\"logo\\":{\\"@type\\":\\"ImageObject\\",\\"url\\":\\"https://friday-go.icu/logo.png\\"}},\\"description\\":\\"在 Vibe Coding 时代，ChatGPT 5.1 已经坐在你的工位上了。这篇文章聊的不是“会不会被 AI 替代”，而是：如何和 ChatGPT 5.1 一起写代码，让它加班，你下班。\\",\\"inLanguage\\":\\"zh-CN\\",\\"mainEntityOfPage\\":{\\"@type\\":\\"WebPage\\",\\"@id\\":\\"https://friday-go.icu/zh/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代\\"},\\"keywords\\":[\\"vibe coding\\",\\"chatgpt 5.1 coding\\",\\"ai 写代码 实战\\",\\"开发者 会不会被 ai 替代\\",\\"ai 编程 工作流\\",\\"chatgpt 辅助 编程\\",\\"ai 代码 质量\\",\\"ai 调试 难点\\",\\"开发者 职业 焦虑 ai\\"],\\"articleSection\\":\\"工具\\"}"]]},"headers":[],"relativePath":"zh/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代.md","filePath":"zh/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代.md","lastUpdated":1764638248000}'),s={name:"zh/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代.md"};function t(o,a,p,r,d,c){return n(),l("div",{"data-pagefind-body":!0,"data-pagefind-meta":"date:1764288000000"},a[0]||(a[0]=[e(`<h1 id="vibe-coding-时代的开发者-如何跟-chatgpt-5-1-一起写代码-而不是被替代" tabindex="-1">Vibe Coding 时代的开发者：如何跟 ChatGPT 5.1 一起写代码，而不是被替代 <a class="header-anchor" href="#vibe-coding-时代的开发者-如何跟-chatgpt-5-1-一起写代码-而不是被替代" aria-label="Permalink to &quot;Vibe Coding 时代的开发者：如何跟 ChatGPT 5.1 一起写代码，而不是被替代&quot;">​</a></h1><blockquote><p>你有没有这种体验：IDE 里一行代码都没敲，任务已经“完成 80%”；<br> 结果线上一挂，leader 问是谁写的，你看着屏幕沉默不语：<br> “不能说完全不是我写的，只能说大部分不是我写的。”</p></blockquote><p>欢迎来到 <strong>Vibe Coding 时代</strong>。<br> 键盘声越来越少，prompt 越来越长，Bug 依然如约而至。</p><p>这篇文章不聊“AI 会不会抢程序员饭碗”这种宏大问题，只聊一件更现实的事：</p><blockquote><p><strong>既然 ChatGPT 5.1 已经坐在你工位上了，你怎么跟它一起干活，<br> 让它加班，让你下班，而不是反过来。</strong></p></blockquote><hr><h2 id="一、先说清楚-什么是-vibe-coding" tabindex="-1">一、先说清楚：什么是 Vibe Coding？ <a class="header-anchor" href="#一、先说清楚-什么是-vibe-coding" aria-label="Permalink to &quot;一、先说清楚：什么是 Vibe Coding？&quot;">​</a></h2><p>Vibe Coding 这玩意，本质上就一句话：</p><blockquote><p><strong>“我不想在语法细节里打转，我只想描述我要什么，然后看着 AI 把代码敲出来。”</strong></p></blockquote><p>再配上：</p><ul><li>一点 Lofi 音乐</li><li>一块超宽屏</li><li>两盏氛围灯</li><li>一杯装在马克杯里的某种液体（咖啡 / 茶 / 功能饮料 / 柠檬水都行）</li></ul><p>你就拥有了社交媒体意义上的——<strong>“认真写代码的一天”</strong>。</p><p>技术视角下，它其实是三件事叠加：</p><ul><li><strong>自然语言建模</strong>：用中文 / 英文描述需求、约束、边界条件</li><li><strong>AI 代码生成</strong>：ChatGPT 5.1 / Copilot / 其他 LLM 把它翻译成代码</li><li><strong>人类审计与重构</strong>：你来决定哪些能用，哪些必须砍掉重写</li></ul><p>如果你只做前两步，不做第三步，那不叫 Vibe Coding，叫 <strong>Vibe Gambling</strong>。</p><hr><h2 id="二、最常见的翻车现场-不是-ai-太蠢-是你太相信它" tabindex="-1">二、最常见的翻车现场：不是 AI 太蠢，是你太相信它 <a class="header-anchor" href="#二、最常见的翻车现场-不是-ai-太蠢-是你太相信它" aria-label="Permalink to &quot;二、最常见的翻车现场：不是 AI 太蠢，是你太相信它&quot;">​</a></h2><p>聊怎么用之前，先看几个大家普遍遇到的坑。读着读着，如果你觉得“怎么这么眼熟”，说明你已经深度体验过了。</p><h3 id="_1-看起来很对-就是跑不起来" tabindex="-1">1. “看起来很对，就是跑不起来” <a class="header-anchor" href="#_1-看起来很对-就是跑不起来" aria-label="Permalink to &quot;1. “看起来很对，就是跑不起来”&quot;">​</a></h3><p>典型现象：</p><ul><li>本地一跑，能过 happy path；</li><li>真上测试环境，一堆边界条件全炸；</li><li>出了问题往下翻代码，发现一半逻辑你压根没细看过。</li></ul><p>原因很简单：</p><ul><li>传统开发是：<strong>“写代码 → 自己理解”</strong>；</li><li>Vibe Coding 很容易变成：<strong>“AI 生成 → 大致扫一眼 → 直接 copy”</strong>。</li></ul><p>人类天生不擅长做“只看结果不看过程”的审计工作，尤其是几百行一坨的时候。</p><h3 id="_2-调试体验-像在给陌生人免费加班" tabindex="-1">2. 调试体验：像在给陌生人免费加班 <a class="header-anchor" href="#_2-调试体验-像在给陌生人免费加班" aria-label="Permalink to &quot;2. 调试体验：像在给陌生人免费加班&quot;">​</a></h3><p>以前 debug 是在跟“过去的自己”对话：</p><blockquote><p>“我当时为什么这么写？哦原来是为了 xxx。”</p></blockquote><p>现在 debug 更像在翻别人 GitHub 仓库：</p><ul><li>命名风格和你完全不一样</li><li>错误处理哲学跟你团队约定完全相反</li><li>日志要么没有，要么一股“教学示例味”</li></ul><p>你不是不会 debug，你只是不认识这个写代码的人——而那个人叫 ChatGPT。</p><h3 id="_3-demo-非常丝滑-上生产惨不忍睹" tabindex="-1">3. Demo 非常丝滑，上生产惨不忍睹 <a class="header-anchor" href="#_3-demo-非常丝滑-上生产惨不忍睹" aria-label="Permalink to &quot;3. Demo 非常丝滑，上生产惨不忍睹&quot;">​</a></h3><p>Vibe Coding 特别擅长：</p><ul><li>写 demo</li><li>录视频</li><li>写博客里的代码片段</li></ul><p>但线上服务需要的是：</p><ul><li><strong>可观测性</strong>（日志、指标、Trace 一条龙）</li><li><strong>一致的错误处理策略</strong></li><li><strong>性能与资源使用的边界</strong></li></ul><p>这些东西，ChatGPT 5.1 不是写不出来，而是——<strong>你不提醒，它也不会主动上心。</strong></p><hr><h2 id="三、重新分工-你当导演和架构师-chatgpt-5-1-当高级工具人" tabindex="-1">三、重新分工：你当导演和架构师，ChatGPT 5.1 当高级工具人 <a class="header-anchor" href="#三、重新分工-你当导演和架构师-chatgpt-5-1-当高级工具人" aria-label="Permalink to &quot;三、重新分工：你当导演和架构师，ChatGPT 5.1 当高级工具人&quot;">​</a></h2><p>想跟 5.1 长期和平共处，核心是换一套身份认知：</p><blockquote><p><strong>别把自己当“写代码的人”，而是当“组织智能的人”。</strong></p></blockquote><p>听起来有点玄？直接给一套可以明天就试的工作流。</p><h3 id="_1-先别让它写代码-先让它-打草稿" tabindex="-1">1. 先别让它写代码，先让它“打草稿” <a class="header-anchor" href="#_1-先别让它写代码-先让它-打草稿" aria-label="Permalink to &quot;1. 先别让它写代码，先让它“打草稿”&quot;">​</a></h3><p>无论是 Go / PHP / TypeScript，都可以这样来：</p><ol><li><p><strong>写清楚上下文和约束</strong>，包括但不限于：</p><ul><li>项目结构（单体 / 微服务 / Monorepo）</li><li>错误处理约定（是否统一 wrap、是否用统一中间件处理）</li><li>日志方案（用什么库、日志级别、字段规范）</li></ul></li><li><p>然后对 5.1 说：<br><strong>“先别写实现，先帮我列：模块切分 / 结构体设计 / 接口定义 / 错误类型设计。”</strong></p></li><li><p>你做的事只有一件：<br><strong>在这个“结构草稿”上疯狂批注</strong>：</p><ul><li>这里太复杂了，拆简单点</li><li>这里要考虑幂等</li><li>这里需要预留熔断 / 重试</li><li>这里未来可能会拆成独立服务</li></ul></li></ol><p>这一步的思路是：</p><blockquote><p>让 5.1 把你脑子里的想法拉成“白板草图”，而不是直接生成 500 行成品。</p></blockquote><h3 id="_2-按模块生成-而不是-一口气全写完" tabindex="-1">2. 按模块生成，而不是“一口气全写完” <a class="header-anchor" href="#_2-按模块生成-而不是-一口气全写完" aria-label="Permalink to &quot;2. 按模块生成，而不是“一口气全写完”&quot;">​</a></h3><p>等结构你认可之后，再按模块下指令：</p><ul><li>“现在只实现 <code>UserRepository</code>，要求：……”</li><li>“帮我写这部分的单元测试，覆盖这几种失败场景……”</li><li>“把错误处理统一改成我们项目里的风格：wrapped error + 统一中间件……”</li></ul><p>每次生成代码，都让 5.1 带上：</p><ul><li>简单的注释</li><li>失败路径的处理</li><li>一小段“自我审查”，例如： <ul><li>这段代码有哪些潜在风险？</li><li>如果把并发量放大 10 倍会怎样？</li><li>哪些地方最可能出 bug？</li></ul></li></ul><p>你要做的，不是盯着每一行语法，而是看：</p><ul><li>结构有没有踩你团队的禁区</li><li>有没有一看就不舒服的地方（抽象过度 / 分层过细 / 命名别扭）</li></ul><h3 id="_3-最关键的一步-让-5-1-给自己挑刺" tabindex="-1">3. 最关键的一步：让 5.1 给自己挑刺 <a class="header-anchor" href="#_3-最关键的一步-让-5-1-给自己挑刺" aria-label="Permalink to &quot;3. 最关键的一步：让 5.1 给自己挑刺&quot;">​</a></h3><p>这一步很多人压根没用过，但效果非常好：</p><blockquote><p>“请你用严苛 code review 的标准，审查一下你刚才写的这段代码，从</p><ul><li>可读性</li><li>性能</li><li>错误处理</li><li>日志 &amp; 可观测性<br> 这四个方面指出问题，并给出更好的版本。”</li></ul></blockquote><p>你会发现：<strong>同一个 5.1，认真起来和敷衍的时候，代码完全不是一个水平。</strong></p><p>你的工作变成：</p><ul><li>在两版之间做 trade-off</li><li>决定是“稍微复杂但是健壮”，还是“简单一点但可接受”</li></ul><hr><h2 id="三-五、真实案例-我用-chatgpt-5-1-重构博客的-seo-关键词优化脚本" tabindex="-1">三.五、真实案例：我用 ChatGPT 5.1 重构博客的 SEO 关键词优化脚本 <a class="header-anchor" href="#三-五、真实案例-我用-chatgpt-5-1-重构博客的-seo-关键词优化脚本" aria-label="Permalink to &quot;三.五、真实案例：我用 ChatGPT 5.1 重构博客的 SEO 关键词优化脚本&quot;">​</a></h2><p>这是我上周末真实遇到的一个任务，也是我第一次完整体验&quot;Vibe Coding&quot;工作流的过程。</p><h3 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h3><p>我的技术博客 <code>friday-go.icu</code> 用 VitePress 搭建，有 100+ 篇技术文章。最近发现 Google Search Console 里显示&quot;低价值内容&quot;，需要优化 SEO。</p><p>核心需求：</p><ul><li>批量扫描所有 Markdown 文件的 frontmatter</li><li>检查哪些文章的 <code>keywords</code> 字段为空或过于简单</li><li>根据文章标题和内容，自动生成 10-15 个中文长尾关键词</li><li>把优化后的 keywords 写回文件，不破坏原有格式</li></ul><p>如果纯手写，我估计要 2-3 小时（文件遍历 + YAML 解析 + OpenAI API + 错误处理）。</p><h3 id="第一步-让-5-1-先画草图-不写代码" tabindex="-1">第一步：让 5.1 先画草图（不写代码） <a class="header-anchor" href="#第一步-让-5-1-先画草图-不写代码" aria-label="Permalink to &quot;第一步：让 5.1 先画草图（不写代码）&quot;">​</a></h3><p>我的完整 prompt：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>我有一个 Go 项目需求：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>【上下文】</span></span>
<span class="line"><span>- 项目是 VitePress 技术博客，文件结构：docs/zh/golang/*.md, docs/zh/工具/*.md</span></span>
<span class="line"><span>- 每个 Markdown 文件开头有 YAML frontmatter，包含 title, description, keywords 等字段</span></span>
<span class="line"><span>- 我想批量优化 keywords 字段，让它们更符合中文 SEO 长尾词习惯</span></span>
<span class="line"><span></span></span>
<span class="line"><span>【约束】</span></span>
<span class="line"><span>- 不能破坏原有 YAML 格式（缩进、引号、多行等）</span></span>
<span class="line"><span>- 如果 keywords 已经有内容，跳过不处理</span></span>
<span class="line"><span>- 需要调用 OpenAI API 生成关键词（用 gpt-4o-mini，控制成本）</span></span>
<span class="line"><span>- 日志必须清晰：哪些文件处理了、哪些跳过了、哪些报错了</span></span>
<span class="line"><span></span></span>
<span class="line"><span>【不要直接写代码】</span></span>
<span class="line"><span>请先帮我列出：</span></span>
<span class="line"><span>1. 核心模块划分（比如：文件扫描模块、YAML 解析模块、AI 生成模块、文件写回模块）</span></span>
<span class="line"><span>2. 主要的 struct 和 interface 设计</span></span>
<span class="line"><span>3. 错误处理策略（哪些错误要中断、哪些可以降级）</span></span>
<span class="line"><span>4. 并发设计（要不要并发处理多个文件？）</span></span></code></pre></div><p><strong>5.1 给的草图（摘要）</strong>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>模块设计：</span></span>
<span class="line"><span>1. FileScanner: 递归扫描目录，过滤 .md 文件</span></span>
<span class="line"><span>2. FrontmatterParser: 解析 YAML，提取 title/description/keywords</span></span>
<span class="line"><span>3. KeywordGenerator: 调用 OpenAI API，生成关键词列表</span></span>
<span class="line"><span>4. FileWriter: 把优化后的 keywords 写回文件，保持格式</span></span>
<span class="line"><span></span></span>
<span class="line"><span>并发建议：</span></span>
<span class="line"><span>- 用 worker pool 模式（5 个并发），避免 OpenAI API 限流</span></span>
<span class="line"><span>- 每个文件独立处理，失败不影响其他文件</span></span>
<span class="line"><span></span></span>
<span class="line"><span>错误策略：</span></span>
<span class="line"><span>- API 调用失败：记录 warning，跳过该文件</span></span>
<span class="line"><span>- 文件写入失败：记录 error，但不中断流程</span></span></code></pre></div><p>我在这个草图上做了两处批注：</p><ul><li><strong>&quot;5 个并发太多了，OpenAI API 有 RPM 限制，改成 3 个&quot;</strong></li><li><strong>&quot;KeywordGenerator 要支持重试机制（最多 3 次），避免偶发网络抖动&quot;</strong></li></ul><h3 id="第二步-按模块让-5-1-生成代码" tabindex="-1">第二步：按模块让 5.1 生成代码 <a class="header-anchor" href="#第二步-按模块让-5-1-生成代码" aria-label="Permalink to &quot;第二步：按模块让 5.1 生成代码&quot;">​</a></h3><p>我先让它写 <code>FileScanner</code>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>现在先实现 FileScanner 模块，要求：</span></span>
<span class="line"><span>- 递归扫描指定目录下的 .md 文件</span></span>
<span class="line"><span>- 返回文件路径列表</span></span>
<span class="line"><span>- 跳过 node_modules, .git, public 等无关目录</span></span>
<span class="line"><span>- 用标准库 filepath.Walk，不要引入额外依赖</span></span></code></pre></div><p>5.1 给出了代码，我发现有两个小问题：</p><ul><li>它用了 <code>ioutil.ReadDir</code>（已废弃），我让它改成 <code>os.ReadDir</code></li><li>没考虑软链接，我让它加了 <code>filepath.EvalSymlinks</code> 检查</li></ul><p>然后是 <code>FrontmatterParser</code>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>实现 FrontmatterParser，要求：</span></span>
<span class="line"><span>- 用 gopkg.in/yaml.v3 解析 frontmatter</span></span>
<span class="line"><span>- 提取 title, description, keywords 字段</span></span>
<span class="line"><span>- keywords 可能是 string 也可能是 []string，都要支持</span></span>
<span class="line"><span>- 如果 keywords 已存在且非空，返回 nil（表示跳过）</span></span></code></pre></div><p>这一块它写得还不错，但我让它补了一个边界条件：</p><ul><li><strong>&quot;如果 frontmatter 格式错误（比如缺少 <code>---</code> 分隔符），不要 panic，而是返回明确的错误&quot;</strong></li></ul><h3 id="第三步-让-5-1-自己审查-优化" tabindex="-1">第三步：让 5.1 自己审查 + 优化 <a class="header-anchor" href="#第三步-让-5-1-自己审查-优化" aria-label="Permalink to &quot;第三步：让 5.1 自己审查 + 优化&quot;">​</a></h3><p>在生成完 <code>KeywordGenerator</code>（调用 OpenAI API 的部分）后，我用了你文章里提到的&quot;让 5.1 挑刺&quot;：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>请用严苛的 code review 标准，从以下角度审查你刚写的 KeywordGenerator：</span></span>
<span class="line"><span>1. 错误处理是否健壮（API 超时、限流、返回空结果）</span></span>
<span class="line"><span>2. 日志是否清晰（调试时能快速定位问题）</span></span>
<span class="line"><span>3. 成本控制（是否可以缓存结果、减少重复调用）</span></span>
<span class="line"><span>4. 性能（是否有不必要的内存拷贝）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>给出改进版本。</span></span></code></pre></div><p><strong>5.1 的自我审查（关键点）</strong>：</p><ul><li><strong>问题 1</strong>：没处理 OpenAI API 返回的 JSON 格式错误<br> → 改进：增加 JSON 反序列化的错误处理</li><li><strong>问题 2</strong>：日志只打印&quot;调用成功&quot;，看不到具体生成了多少关键词<br> → 改进：改成 <code>log.Printf(&quot;Generated %d keywords for &#39;%s&#39;&quot;, len(keywords), title)</code></li><li><strong>问题 3</strong>：可以增加本地缓存，避免同一篇文章重复调用 API<br> → 改进：用 <code>sync.Map</code> 做内存缓存（key = title, value = keywords）</li></ul><p>我采纳了前两个，第三个暂时没做（因为是一次性脚本，不需要缓存）。</p><h3 id="最终效果" tabindex="-1">最终效果 <a class="header-anchor" href="#最终效果" aria-label="Permalink to &quot;最终效果&quot;">​</a></h3><p><strong>代码行数</strong>：约 280 行（包含注释和错误处理）<br><strong>实际耗时</strong>：</p><ul><li>和 5.1 对话 + 改代码：<strong>55 分钟</strong></li><li>真正运行 + 修 bug：<strong>20 分钟</strong></li><li><strong>总计：1 小时 15 分</strong></li></ul><p><strong>如果纯手写</strong>，我估计要：</p><ul><li>写代码：1.5 小时</li><li>调试 YAML 解析的边界条件：30 分钟</li><li><strong>总计：2 小时</strong></li></ul><p>节省了 <strong>40% 时间</strong>，但关键是：</p><ul><li>我花在&quot;写代码&quot;上的时间少了 70%</li><li>我花在&quot;设计、审查、决策&quot;上的时间多了 50%</li></ul><p><strong>最终上线运行效果</strong>：</p><ul><li>成功处理了 87 篇文章</li><li>跳过了 23 篇（已有 keywords）</li><li>失败了 2 篇（YAML 格式损坏，手动修复）</li></ul><p>（<strong>这里后续补一张截图：终端输出日志，显示&quot;处理进度 + 成功/跳过/失败统计&quot;</strong>）</p><h3 id="我从这次经历里学到的-3-件事" tabindex="-1">我从这次经历里学到的 3 件事 <a class="header-anchor" href="#我从这次经历里学到的-3-件事" aria-label="Permalink to &quot;我从这次经历里学到的 3 件事&quot;">​</a></h3><ol><li><p><strong>&quot;草稿优先&quot;真的有用</strong><br> 一开始让 5.1 画结构，比直接让它写代码，效率高太多。<br> 我可以在&quot;草稿阶段&quot;就发现设计问题，而不是等到代码写完再改。</p></li><li><p><strong>&quot;让 AI 自己挑刺&quot;是个杀手锏</strong><br> 5.1 认真 review 自己代码的时候，质量明显提升一个档次。<br> 但你得给它明确的维度（错误处理、日志、性能），它才知道往哪个方向改。</p></li><li><p><strong>你的角色是&quot;导演 + 质检员&quot;，不是&quot;打字员&quot;</strong><br> 整个过程中，我几乎没&quot;手写&quot;超过 10 行代码，但我做了无数次决策：</p><ul><li>3 个并发还是 5 个？</li><li>要不要缓存？</li><li>错误要中断还是降级？</li><li>日志打到什么粒度？</li></ul><p>这些决策，才是&quot;不可替代&quot;的部分。</p></li></ol><hr><h2 id="四、我会不会被-更会用-5-1-的人-替代" tabindex="-1">四、我会不会被&quot;更会用 5.1 的人&quot;替代？ <a class="header-anchor" href="#四、我会不会被-更会用-5-1-的人-替代" aria-label="Permalink to &quot;四、我会不会被&quot;更会用 5.1 的人&quot;替代？&quot;">​</a></h2><p>坦白讲，会有一部分人被替代，但不是因为 5.1，而是因为：</p><blockquote><p>他既不会写好代码，也不会用好 5.1。</p></blockquote><p>我们可以把开发者粗暴地分成三种：</p><h3 id="_1-只会手写代码-但拒绝用-ai-的" tabindex="-1">1. 只会手写代码，但拒绝用 AI 的 <a class="header-anchor" href="#_1-只会手写代码-但拒绝用-ai-的" aria-label="Permalink to &quot;1. 只会手写代码，但拒绝用 AI 的&quot;">​</a></h3><ul><li>优点：基本功扎实</li><li>缺点：产出速度会被彻底碾压</li><li>未来角色：可能会在“极端可靠领域”继续有需求（内核、安全、极高性能场景），但数量有限</li></ul><h3 id="_2-只会写-prompt-不懂工程和架构的" tabindex="-1">2. 只会写 prompt，不懂工程和架构的 <a class="header-anchor" href="#_2-只会写-prompt-不懂工程和架构的" aria-label="Permalink to &quot;2. 只会写 prompt，不懂工程和架构的&quot;">​</a></h3><ul><li>优点：前期看起来产能很高</li><li>缺点：项目一大就会崩盘，Bug / 技债 / 运维压力全找上门</li><li>未来角色：会被下一代工具替代，因为任何人都能写“差不多的 prompt”</li></ul><h3 id="_3-既懂工程-又会-orchestrate-ai-的" tabindex="-1">3. 既懂工程，又会 orchestrate AI 的 <a class="header-anchor" href="#_3-既懂工程-又会-orchestrate-ai-的" aria-label="Permalink to &quot;3. 既懂工程，又会 orchestrate AI 的&quot;">​</a></h3><p>他们会做的事包括：</p><ul><li>能把需求拆成合理的模块和边界</li><li>知道哪些适合交给 5.1，哪些必须自己写</li><li>知道如何审计 5.1 的输出，让它为你的架构服务</li></ul><p>未来，这些人更像是“<strong>放大器</strong>”：</p><ul><li>一个人可以顶过去三五个纯手工开发的产出</li><li>他们不是在跟 AI 竞争，而是在用 AI 放大自己的判断力</li></ul><p>你想成为哪一类，大概率是可以自己选的。</p><hr><h2 id="五、在-vibe-coding-时代-怎么保住-硬功夫" tabindex="-1">五、在 Vibe Coding 时代，怎么保住“硬功夫”？ <a class="header-anchor" href="#五、在-vibe-coding-时代-怎么保住-硬功夫" aria-label="Permalink to &quot;五、在 Vibe Coding 时代，怎么保住“硬功夫”？&quot;">​</a></h2><p>既然我们承认要和 5.1 合作，那“别被替代”就不是靠拒绝使用，而是靠：</p><blockquote><p>在 AI 极擅长的地方借力，在 AI 不擅长的地方补位。</p></blockquote><p>换句话说：<strong>该让它做的让它做，该你硬上的别躲。</strong></p><p>给你几个简单可执行的习惯：</p><h3 id="_1-每周保持一段-纯手写时间" tabindex="-1">1. 每周保持一段“纯手写时间” <a class="header-anchor" href="#_1-每周保持一段-纯手写时间" aria-label="Permalink to &quot;1. 每周保持一段“纯手写时间”&quot;">​</a></h3><p>不用太长，30–60 分钟就行。<br> 可以做这些事：</p><ul><li>手写一个常见数据结构 / 算法</li><li>重构一段老代码，不借助 AI，让自己重新走一遍决策路径</li><li>为现有项目写一份“设计说明书”或 README 的架构部分</li></ul><p>这段时间的目标不是“提高效率”，而是<strong>给大脑做力量训练</strong>。</p><h3 id="_2-每次用-5-1-都让它-解释一下为什么这么写" tabindex="-1">2. 每次用 5.1，都让它“解释一下为什么这么写” <a class="header-anchor" href="#_2-每次用-5-1-都让它-解释一下为什么这么写" aria-label="Permalink to &quot;2. 每次用 5.1，都让它“解释一下为什么这么写”&quot;">​</a></h3><p>比如：</p><ul><li>“请用架构师角度解释一下，你为什么这样划分模块？”</li><li>“如果改用事件驱动 / CQRS / 另一种模式，会发生什么变化？”</li><li>“这段实现里，哪部分最脆弱，最值得写测试？”</li></ul><p>你会得到一段“教材式解释”。<br> 这段解释，比那几百行代码更值钱。</p><h3 id="_3-故意跟它-唱反调-一两次" tabindex="-1">3. 故意跟它“唱反调”一两次 <a class="header-anchor" href="#_3-故意跟它-唱反调-一两次" aria-label="Permalink to &quot;3. 故意跟它“唱反调”一两次&quot;">​</a></h3><p>当 5.1 给你一个方案时，主动问：</p><ul><li>“给我一个完全相反风格的实现，比如从 OOP 改成偏函数式风格。”</li><li>“如果我不允许使用某个第三方库，你会怎么改？”</li></ul><p>你会开始学会 <strong>比较方案，而不是被第一个答案牵着走</strong>。<br> 慢慢地，你会发现自己在做的，其实已经是架构设计而不是简单“写代码”。</p><hr><h2 id="六、别忘了-安全、可观测性和规范-依然是你的锅" tabindex="-1">六、别忘了：安全、可观测性和规范，依然是你的锅 <a class="header-anchor" href="#六、别忘了-安全、可观测性和规范-依然是你的锅" aria-label="Permalink to &quot;六、别忘了：安全、可观测性和规范，依然是你的锅&quot;">​</a></h2><p>无论 5.1 写了多少代码，有三件事永远写在你名字上：</p><ul><li><strong>安全</strong>：有没有把 token 写在代码里，有没有做输入校验</li><li><strong>可观测性</strong>：出了问题你追不追得到</li><li><strong>团队规范</strong>：代码风格、错误处理、日志标准</li></ul><p>给一套“最小自查清单”，你可以直接贴进项目里：</p><ul><li>所有外部调用： <ul><li>是否有超时与重试策略？</li><li>失败时是否打点 / 记日志？</li></ul></li><li>错误处理： <ul><li>是否统一 wrap / 分类？</li><li>是否会在边界层（HTTP / RPC）归一化？</li></ul></li><li>日志： <ul><li>是否包含 trace id / request id？</li><li>是否避免在日志里打出敏感信息？</li></ul></li></ul><p>你完全可以让 5.1 来帮你写这张清单、甚至自动检查一遍代码，<br> 但<strong>勾不勾选，是你的责任</strong>。</p><hr><h2 id="七、vibe-coding-时代-最好的位置在哪里" tabindex="-1">七、Vibe Coding 时代，最好的位置在哪里？ <a class="header-anchor" href="#七、vibe-coding-时代-最好的位置在哪里" aria-label="Permalink to &quot;七、Vibe Coding 时代，最好的位置在哪里？&quot;">​</a></h2><p>如果把软件开发流程粗暴拆开，大致是这样：</p><blockquote><p>需求 → 架构 &amp; 设计 → 编码 &amp; 测试 → 部署 &amp; 监控 → 运营 &amp; 迭代</p></blockquote><p>Vibe Coding 和 ChatGPT 5.1，目前最厉害的是这几个环节：</p><ul><li>编码：大量样板代码、胶水代码、CRUD</li><li>测试：生成测试用例、mock、简单集成测试脚手架</li><li>文档：接口文档、使用说明、CHANGELOG 草稿</li></ul><p>而最不容易被替代的是：</p><ul><li><strong>需求拆解</strong>：你到底要解决什么问题</li><li><strong>架构折中</strong>：在复杂度 / 性能 / 成本 / 上线时间之间做平衡</li><li><strong>工程规范与团队文化</strong>：<br> 同样的 AI 工具，在你手上和别人手上，产物差距会非常大</li></ul><p>所以，这篇文章真正想说的一句话是：</p><blockquote><p>别再纠结“会不会写代码会被替代”，<br> 把精力放在“如何更好地组织智能”——包括你自己和 ChatGPT 5.1。</p></blockquote><hr><h2 id="八、小结-明天就可以尝试的-3-个小实验" tabindex="-1">八、小结：明天就可以尝试的 3 个小实验 <a class="header-anchor" href="#八、小结-明天就可以尝试的-3-个小实验" aria-label="Permalink to &quot;八、小结：明天就可以尝试的 3 个小实验&quot;">​</a></h2><p>如果你看到这里，可以试试下面三件小事：</p><h3 id="实验-1-只让-5-1-画草图" tabindex="-1">实验 1：只让 5.1 画草图 <a class="header-anchor" href="#实验-1-只让-5-1-画草图" aria-label="Permalink to &quot;实验 1：只让 5.1 画草图&quot;">​</a></h3><p>找一个你准备写的新功能，禁止它直接写实现，只让它列：</p><ul><li>模块划分</li><li>接口定义</li><li>数据结构设计</li><li>错误类型设计</li></ul><p>你在上面批注，感受一下自己从“码农”变成“导演”的过程。</p><h3 id="实验-2-请-5-1-做一次-严厉的-code-reviewer" tabindex="-1">实验 2：请 5.1 做一次“严厉的 code reviewer” <a class="header-anchor" href="#实验-2-请-5-1-做一次-严厉的-code-reviewer" aria-label="Permalink to &quot;实验 2：请 5.1 做一次“严厉的 code reviewer”&quot;">​</a></h3><p>把你最近写的（或它写的）一段核心代码扔给它，让它从：</p><ul><li>可读性</li><li>性能</li><li>错误处理</li><li>日志 &amp; 可观测性</li></ul><p>这四个维度挑刺并重写一版。你只做一件事：<br><strong>挑你喜欢的部分 merge 回项目。</strong></p><h3 id="实验-3-给未来的自己写一封-使用说明" tabindex="-1">实验 3：给未来的自己写一封“使用说明” <a class="header-anchor" href="#实验-3-给未来的自己写一封-使用说明" aria-label="Permalink to &quot;实验 3：给未来的自己写一封“使用说明”&quot;">​</a></h3><p>用自然语言写下：</p><ul><li>你希望项目里的错误处理长什么样</li><li>你接受 / 不接受哪些快捷方式</li><li>哪些“为了赶上线的妥协”，未来必须还债</li></ul><p>然后把这封“说明书”交给 ChatGPT 5.1，让它以后都按这个标准来生成代码。</p><p>当你开始这样用 ChatGPT 5.1 的时候，你就已经从：</p><ul><li>“担心被替代的那一拨人”，</li></ul><p>缓缓走向：</p><ul><li>“把 AI 当成增幅器的那一拨人”。</li></ul><h3 id="延伸阅读-把想法落地到真实项目" tabindex="-1">延伸阅读：把想法落地到真实项目 <a class="header-anchor" href="#延伸阅读-把想法落地到真实项目" aria-label="Permalink to &quot;延伸阅读：把想法落地到真实项目&quot;">​</a></h3><ul><li><strong>想系统挑选和对比 AI 工具</strong>：可以看这篇<br> 👉 <a href="/Tools/AI-Tools-Directory-2025-Best-AI-Apps-and-Use-Cases">AI Tools Directory 2025 — The Ultimate Guide to the Best AI Apps and Use Cases</a></li><li><strong>想在 PHP 项目里落地本地 LLM 能力</strong>：可以从 Function Calling 开始<br> 👉 <a href="/PHP/Making-Local-LLMs-Support-Function-Calling-Like-OpenAI-PHP-Async-Implementation">Making Local LLMs Support Function Calling Like OpenAI - PHP Async Implementation Guide</a></li><li><strong>如果你是 Go 后端，想把“工程规范”落到代码里</strong>：可以先补一课错误处理<br> 👉 <a href="/golang/Go-Error-Handling-Best-Practices-2025-Complete-Guide">Go Error Handling Best Practices 2025: Complete Guide</a></li></ul><p>Vibe 可以继续，Coding 也要硬。<br> 能一起弹琴的，才配一起 Vibe。</p>`,173)]))}const g=i(s,[["render",t]]);export{u as __pageData,g as default};
