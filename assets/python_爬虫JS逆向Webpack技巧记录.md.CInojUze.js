import{_ as a,c as i,o as t,a6 as e}from"./chunks/framework.CwlnujpX.js";const d=JSON.parse('{"title":"爬虫JS逆向Webpack技巧记录","description":"爬虫JS逆向Webpack技巧记录","frontmatter":{"title":"爬虫JS逆向Webpack技巧记录","date":"2023-05-15T10:14:02.000Z","tags":["爬虫","python","Webpack"],"description":"爬虫JS逆向Webpack技巧记录","author":"PFinal南丞","keywords":"爬虫JS逆向Webpack技巧记录, 爬虫, JS, Webpack","head":[["meta",{"name":"keywords","content":"爬虫JS逆向Webpack技巧记录, 爬虫, JS, Webpack,pfinalclub, git, gitsite, javascript, node, jquery, python, php, laravel, sql, database, linux, operating system, os, cpu, verilog, risc-v, bitcoin, ethereum, ai, 教程, 软件, 编程, 开发, 运维, 云计算, 网络, 互联网, 比特币, 以太坊, 操作系统, 智能合约, 数字货币, 爬虫, 逆向"}]]},"headers":[],"relativePath":"python/爬虫JS逆向Webpack技巧记录.md","filePath":"python/爬虫JS逆向Webpack技巧记录.md","lastUpdated":1742363014000}'),p={name:"python/爬虫JS逆向Webpack技巧记录.md"};function l(n,s,h,k,r,o){return t(),i("div",{"data-pagefind-body":!0},s[0]||(s[0]=[e(`<h1 id="爬虫js逆向webpack技巧记录" tabindex="-1">爬虫JS逆向Webpack技巧记录 <a class="header-anchor" href="#爬虫js逆向webpack技巧记录" aria-label="Permalink to &quot;爬虫JS逆向Webpack技巧记录&quot;">​</a></h1><h2 id="概念" tabindex="-1">概念: <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念:&quot;">​</a></h2><p>webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency sgraph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles。所有的资源都是通过JavaScript渲染出来的。</p><h2 id="识别" tabindex="-1">识别: <a class="header-anchor" href="#识别" aria-label="Permalink to &quot;识别:&quot;">​</a></h2><ol><li>如下图所示:</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305151419884.png" alt=""></p><blockquote><p>查看 网页源代码,大部分都是由script标签构成</p></blockquote><ol start="2"><li>如图:</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305160910831.png" alt=""></p><blockquote><p>大部分的webpack 都是可以找到 webpack这个js文件的</p></blockquote><h2 id="结构" tabindex="-1">结构: <a class="header-anchor" href="#结构" aria-label="Permalink to &quot;结构:&quot;">​</a></h2><p>webpack 打包后的js 结构基本上都是 有一个自执行函数用来做加载器 加载模块的,常见的结构如下:</p><h3 id="第一种" tabindex="-1">第一种: <a class="header-anchor" href="#第一种" aria-label="Permalink to &quot;第一种:&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305160951192.png" alt=""></p><p>如图所示:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">funcion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;形参&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;加载器&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;模块&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模块以数组的形式存储,数组中每个元素都是函数</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">..} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这个函数叫做加载器,也可以叫做分发器,所有的模块都是从这个函数加载并执行.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用加载器调用第一个模块</span></span></code></pre></div><h3 id="第二种" tabindex="-1">第二种 <a class="header-anchor" href="#第二种" aria-label="Permalink to &quot;第二种&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305160944584.png" alt=""></p><p>如图所示:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">funcion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;形参&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;加载器&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}({</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;模块&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模块以对象的形式存储,元素都为函数对象</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">..} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这个函数叫做加载器,也可以叫做分发器,所有的模块都是从这个函数加载并执行.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1x2y&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用加载器调用1x2y执行</span></span></code></pre></div><h3 id="第三种" tabindex="-1">第三种 <a class="header-anchor" href="#第三种" aria-label="Permalink to &quot;第三种&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161006212.png" alt=""></p><p><strong>如上图所示,第三种也是最常见的一种.如果模块比较多，就会将模块打包成JS文件, 然后定义一个全局变量 window[&quot;webpackJsonp&quot;] = [ ]，它的作用是存储需要动态导入的模块，然后重写 window[&quot;webpackJsonp&quot;] 数组的 push( ) 方法为 webpackJsonpCallback( ),也就是说 window[&quot;webpackJsonp&quot;].push( ) 其实执行的是 webpackJsonpCallback( ),window[&quot;webpackJsonp&quot;].push( )接收三个参数,第一个参数是模块的ID,第二个参数是 一个数组或者对象,里面定义大量的函数,第三个参数是要调用的函数(可选)。</strong></p><p>每一个JS模块文件开头都是</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window.webpackJsonp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.webpackJsonp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],{}]) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 其中 2 是模块的id  {} 中是要调用的函数对象</span></span></code></pre></div><h2 id="逆向扣取js思路-一" tabindex="-1">逆向扣取JS思路(一) <a class="header-anchor" href="#逆向扣取js思路-一" aria-label="Permalink to &quot;逆向扣取JS思路(一)&quot;">​</a></h2><ol><li>首先找加密参数入口</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161020050.png" alt=""></p><p>如上图所示,加密参数 <em>sign</em></p><ol start="2"><li>找到加载器函数</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161035140.png" alt=""></p><blockquote><p>如上图所示 找到类似这种<strong>n(&#39;xx&#39;)</strong> 调用加载模块的函数然后打断点刷新网页,鼠标移动上去就基本能够找到加载器函数，如下图所示:</p></blockquote><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161038581.png" alt=""></p><ol start="3"><li><p>在加载器函数中的call()方法或者apply()方法打上断点，将加密函数所在的模块和与其相关的模块一起扣取下来。</p></li><li><p>将加密参数升为全局变量导出</p></li></ol><h2 id="逆向扣取js思路-一-1" tabindex="-1">逆向扣取JS思路(一) <a class="header-anchor" href="#逆向扣取js思路-一-1" aria-label="Permalink to &quot;逆向扣取JS思路(一)&quot;">​</a></h2><ol><li>找到加密参数函数入口,确定加密函数所在的模块。</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161044042.png" alt=""></p><ol start="2"><li>找到加密模块 扣下来</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161050194.png" alt=""></p><p>如上图的所示,m函数所在的模块加载了其他模块依次找一下,找到如下图所示的加密模块</p><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161052841.png" alt=""></p><ol start="3"><li>在本地依次往上扣取代码,然后报错 缺啥补啥</li></ol><p>扣下上面的加密模块以后 然后开始补齐其他所缺的函数及其一些参数就可以试试看了</p><blockquote><p>注意: 在加密函数(方法)和加密函数(方法)后打上两个断点，断点在加密函数(方法)断住后，追入到加载器函数,然后在加载器后面下断点(类似 return e[n].call(r.exports, r, r.exports, d) )，跳转到加载器后面的断点，在控制台输入HooK函数(根据不同的加载器函数改变HooK函数代码),取消加载器后面的断点,跳转到加密函数(方法)后的断点,在控制台输入window._wbpk 后得到所有与加密函数有关的模块代码。</p></blockquote><h3 id="其他思路持续更新中" tabindex="-1">其他思路持续更新中... <a class="header-anchor" href="#其他思路持续更新中" aria-label="Permalink to &quot;其他思路持续更新中...&quot;">​</a></h3>`,47)]))}const g=a(p,[["render",l]]);export{d as __pageData,g as default};
