import{_ as a,c as i,o as p,a6 as o}from"./chunks/framework.V1MgpNK7.js";const c=JSON.parse('{"title":"Composer配置文件说明","description":"介绍Composer配置文件的基本概念和使用方法，包括配置文件的位置、依赖管理、包管理、版本控制等。","frontmatter":{"title":"Composer配置文件说明","date":"2022-07-04T17:34:31.000Z","tags":["PHP"],"description":"介绍Composer配置文件的基本概念和使用方法，包括配置文件的位置、依赖管理、包管理、版本控制等。","author":"PFinal南丞","keywords":"Composer, 配置文件, 依赖管理, 包管理, 版本控制,AI,ai","head":[["meta",{"name":"keywords","content":"Composer, 配置文件, 依赖管理, 包管理, 版本控制,AI,ai,pfinalclub, git, gitsite, javascript, node, jquery, python, php, laravel, sql, database, linux, operating system, os, cpu, verilog, risc-v, bitcoin, ethereum, ai, 教程, 软件, 编程, 开发, 运维, 云计算, 网络, 互联网, 比特币, 以太坊, 操作系统, 智能合约, 数字货币, 爬虫, 逆向"}]]},"headers":[],"relativePath":"工具/Composer配置文件说明.md","filePath":"工具/Composer配置文件说明.md","lastUpdated":1750994934000}'),e={name:"工具/Composer配置文件说明.md"};function t(l,s,n,h,r,k){return p(),i("div",{"data-pagefind-body":!0},s[0]||(s[0]=[o(`<h1 id="composer配置文件说明" tabindex="-1">Composer配置文件说明 <a class="header-anchor" href="#composer配置文件说明" aria-label="Permalink to &quot;Composer配置文件说明&quot;">​</a></h1><h3 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h3><p>安装 Composer，你只需要下载 composer.phar 可执行文件。</p><blockquote><p>curl -sS <a href="https://getcomposer.org/installer" target="_blank" rel="noreferrer">https://getcomposer.org/installer</a> | php</p></blockquote><p>要检查 Composer 是否正常工作，只需要通过 php 来执行 PHAR：</p><blockquote><p>php composer.phar</p></blockquote><p>这将返回给你一个可执行的命令列表。</p><p><strong>注意：</strong> 你也可以仅执行 --check 选项而无需下载 Composer。 要获取更多的信息请使用 --help。</p><blockquote><p>curl -sS <a href="https://getcomposer.org/installer" target="_blank" rel="noreferrer">https://getcomposer.org/installer</a> | php -- --help</p></blockquote><h3 id="composer-json-项目安装" tabindex="-1">composer.json：项目安装 <a class="header-anchor" href="#composer-json-项目安装" aria-label="Permalink to &quot;composer.json：项目安装&quot;">​</a></h3><p>要开始在你的项目中使用 Composer，你只需要一个 composer.json 文件。该文件包含了项目的依赖和其它的一些元数据。</p><p>这个 JSON format 是很容易编写的。它允许你定义嵌套结构。</p><p><strong>关于 require Key</strong></p><p>第一件事情（并且往往只需要做这一件事），你需要在 composer.json 文件中指定 require key 的值。你只需要简单的告诉 Composer 你的项目需要依赖哪些包。</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;require&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;monolog/monolog&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.0.*&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>你可以看到， require 需要一个 包名称 （例如 monolog/monolog） 映射到 包版本 （例如 1.0.*） 的对象。</p><ul><li>包名称</li></ul><p>包名称由供应商名称和其项目名称构成。</p><p>通常容易产生相同的项目名称，而供应商名称的存在则很好的解决了命名冲突的问题。</p><p>它允许两个不同的人创建同样名为 json 的库，而之后它们将被命名为 igorw/json 和 seldaek/json。</p><p>这里我们需要引入 monolog/monolog，供应商名称与项目的名称相同，对于一个具有唯一名称的项目，我们推荐这么做。它还允许以后在同一个命名空间添加更多的相关项目。如果你维护着一个库，这将使你可以很容易的把它分离成更小的部分。</p><ul><li>包版本</li></ul><p>在前面的例子中，我们引入的 monolog 版本指定为 1.0.*。这表示任何从 1.0 开始的开发分支，它将会匹配 1.0.0、1.0.2 或者 1.0.20。</p><p>版本约束可以用几个不同的方法来指定。</p><blockquote><p>名称 实例 描述</p></blockquote><blockquote><p>确切的版本号 1.0.2 你可以指定包的确切版本。</p></blockquote><blockquote><p>范围 &gt;=1.0 &gt;=1.0,&lt;2.0 &gt;=1.0,&lt;1.1|&gt;=1.2 通过使用比较操作符可以指定有效的版本范围。</p></blockquote><blockquote><p>有效的运算符：&gt;、&gt;=、&lt;、&lt;=、!=。</p></blockquote><blockquote><p>你可以定义多个范围，用逗号隔开，这将被视为一个逻辑AND处理。一个管道符号|将作为逻辑OR处理。 AND 的优先级高于 OR。</p></blockquote><blockquote><p>通配符 1.0.* 你可以使用通配符*来指定一种模式。1.0.*与&gt;=1.0,&lt;1.1是等效的。</p></blockquote><blockquote><p>赋值运算符 ~1.2 这对于遵循语义化版本号的项目非常有用。~1.2相当于&gt;=1.2,&lt;2.0。</p></blockquote><p><strong>下一个重要版本（波浪号运算符）</strong></p><p>~ 最好用例子来解释： ~1.2 相当于 &gt;=1.2,&lt;2.0，而 ~1.2.3 相当于 &gt;=1.2.3,&lt;1.3。正如你所看到的这对于遵循 语义化版本号 的项目最有用。</p><p>一个常见的用法是标记你所依赖的最低版本，像 ~1.2 （允许1.2以上的任何版本，但不包括2.0）。</p><p>由于理论上直到2.0应该都没有向后兼容性问题，所以效果很好。</p><p>你还会看到它的另一种用法，使用 ~ 指定最低版本，但允许版本号的最后一位数字上升。</p><p>注意： 虽然 2.0-beta.1 严格地说是早于 2.0，但是，根据版本约束条件， 例如 ~1.2 却不会安装这个版本。就像前面所讲的 ~1.2 只意味着 .2 部分可以改变，但是 1. 部分是固定的。</p><ul><li>稳定性</li></ul><p>默认情况下只有稳定的发行版才会被考虑在内。</p><p>如果你也想获得 RC、beta、alpha 或 dev 版本，你可以使用 稳定标志。你可以对所有的包做 最小稳定性 设置，而不是每个依赖逐一设置。</p><h3 id="安装依赖包" tabindex="-1">安装依赖包 <a class="header-anchor" href="#安装依赖包" aria-label="Permalink to &quot;安装依赖包&quot;">​</a></h3><p>获取定义的依赖到你的本地项目，只需要调用 composer.phar 运行 install 命令。</p><blockquote><p>php composer.phar install</p></blockquote><p>接着前面的例子，这将会找到 monolog/monolog 的最新版本，并将它下载到 vendor 目录。</p><p>这是一个惯例把第三方的代码到一个指定的目录 vendor。</p><p>如果是 monolog 将会创建 vendor/monolog/monolog 目录。</p><p><strong>小技巧：</strong> 如果你正在使用Git来管理你的项目， 你可能要添加 vendor 到你的 .gitignore 文件中。 你不会希望将所有的代码都添加到你的版本库中。</p><p>另一件事是 install 命令将创建一个 composer.lock 文件到你项目的根目录中。</p><h3 id="composer-lock-锁文件" tabindex="-1">composer.lock - 锁文件 <a class="header-anchor" href="#composer-lock-锁文件" aria-label="Permalink to &quot;composer.lock - 锁文件&quot;">​</a></h3><p>在安装依赖后，Composer 将把安装时确切的版本号列表写入 composer.lock 文件。这将锁定改项目的特定版本。</p><p>请提交你应用程序的 composer.lock （包括 composer.json）到你的版本库中</p><p>这是非常重要的，因为 install 命令将会检查锁文件是否存在，如果存在，它将下载指定的版本（忽略 composer.json 文件中的定义）。</p><p>这意味着，任何人建立项目都将下载与指定版本完全相同的依赖。你的持续集成服务器、生产环境、你团队中的其他开发人员、每件事、每个人都使用相同的依赖，从而减轻潜在的错误对部署的影响。即使你独自开发项目，在六个月内重新安装项目时，你也可以放心的继续工作，即使从那时起你的依赖已经发布了许多新的版本。</p><p>如果不存在 composer.lock 文件，Composer 将读取 composer.json 并创建锁文件。</p><p>这意味着如果你的依赖更新了新的版本，你将不会获得任何更新。此时要更新你的依赖版本请使用 update 命令。这将获取最新匹配的版本（根据你的 composer.json 文件）并将新版本更新进锁文件。</p><blockquote><p>php composer.phar update</p></blockquote><p>如果只想安装或更新一个依赖，你可以白名单它们：</p><blockquote><p>php composer.phar update monolog/monolog [...]</p></blockquote><p><strong>注意：</strong> 对于库，并不一定建议提交锁文件 请参考：库的锁文件.</p><h3 id="packagist" tabindex="-1">Packagist <a class="header-anchor" href="#packagist" aria-label="Permalink to &quot;Packagist&quot;">​</a></h3><p>packagist 是 Composer 的主要资源库。</p><p>一个 Composer 的库基本上是一个包的源：记录了可以得到包的地方。Packagist 的目标是成为大家使用库资源的中央存储平台。</p><p>这意味着你可以 require 那里的任何包。</p><p>当你访问 packagist website (packagist.org)，你可以浏览和搜索资源包。</p><p>任何支持 Composer 的开源项目应该发布自己的包在 packagist 上。虽然并不一定要发布在 packagist 上来使用 Composer，但它使我们的编程生活更加轻松。</p><h3 id="自动加载" tabindex="-1">自动加载 <a class="header-anchor" href="#自动加载" aria-label="Permalink to &quot;自动加载&quot;">​</a></h3><p>对于库的自动加载信息，Composer 生成了一个 vendor/autoload.php 文件。你可以简单的引入这个文件，你会得到一个免费的自动加载支持。</p><blockquote><p>require &#39;vendor/autoload.php&#39;;</p></blockquote><p>这使得你可以很容易的使用第三方代码。例如：如果你的项目依赖 monolog，你就可以像这样开始使用这个类库，并且他们将被自动加载。</p><div class="language-php vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">php</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$log </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Monolog\\Logger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;name&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$log</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pushHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Monolog\\Handler\\StreamHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;app.log&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Monolog\\Logger</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WARNING</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$log</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addWarning</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>你可以在 composer.json 的 autoload 字段中增加自己的 autoloader。</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;autoload&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;psr-4&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;Acme\\\\&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;src/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Composer 将注册一个 PSR-4 autoloader 到 Acme 命名空间。</p><p>你可以定义一个从命名空间到目录的映射。</p><p>此时 src 会在你项目的根目录，与 vendor 文件夹同级。例如 src/Foo.php 文件应该包含 Acme\\Foo 类。</p><p>添加 autoload 字段后，你应该再次运行 install 命令来生成 vendor/autoload.php 文件。</p><p>引用这个文件也将返回 autoloader 的实例，你可以将包含调用的返回值存储在变量中，并添加更多的命名空间。</p><p>这对于在一个测试套件中自动加载类文件是非常有用的，例如。</p><div class="language-php vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">php</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$loader </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> require</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vendor/autoload.php&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$loader</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Acme</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Test</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__DIR__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>除了 PSR-4 自动加载，classmap 也是支持的。这允许类被自动加载，即使不符合 PSR-0 规范。详细请查看 自动加载-参考。</p><p>注意： Composer 提供了自己的 autoloader。如果你不想使用它，你可以仅仅引入 vendor/composer/autoload_*.php 文件，它返回一个关联数组，你可以通过这个关联数组配置自己的 autoloader。</p>`,81)]))}const g=a(e,[["render",t]]);export{c as __pageData,g as default};
