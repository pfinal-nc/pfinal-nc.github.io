import{_ as n,c as a,o as p,a6 as e}from"./chunks/framework.CEUwQ1gD.js";const m=JSON.parse('{"title":"Redis配置文件详解","description":"学习Redis配置文件","frontmatter":{"title":"Redis配置文件详解","date":"2020-06-09T11:31:32.000Z","tags":["Redis"],"description":"学习Redis配置文件","keywords":"Redis配置文件详解, 数据库, redis","author":"PFinal南丞","head":[["meta",{"name":"keywords","content":"Redis配置文件详解, 数据库, redis"}]]},"headers":[],"relativePath":"zh/php/Redis配置文件详解.md","filePath":"zh/php/Redis配置文件详解.md","lastUpdated":1752052166000}'),l={name:"zh/php/Redis配置文件详解.md"};function i(t,s,o,c,r,d){return p(),a("div",{"data-pagefind-body":!0},s[0]||(s[0]=[e(`<h1 id="redis配置文件详解" tabindex="-1">Redis配置文件详解 <a class="header-anchor" href="#redis配置文件详解" aria-label="Permalink to &quot;Redis配置文件详解&quot;">​</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># Redis配置文件样例</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Note on units: when memory size is needed, it is possible to specifiy</span></span>
<span class="line"><span># it in the usual form of 1k 5GB 4M and so forth:</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># 1k =&gt; 1000 bytes</span></span>
<span class="line"><span># 1kb =&gt; 1024 bytes</span></span>
<span class="line"><span># 1m =&gt; 1000000 bytes</span></span>
<span class="line"><span># 1mb =&gt; 1024*1024 bytes</span></span>
<span class="line"><span># 1g =&gt; 1000000000 bytes</span></span>
<span class="line"><span># 1gb =&gt; 1024*1024*1024 bytes</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span></span>
<span class="line"><span># 启用守护进程后，Redis会把pid写到一个pidfile中，在/var/run/redis.pid</span></span>
<span class="line"><span>daemonize no</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span></span>
<span class="line"><span>pidfile /var/run/redis.pid</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定Redis监听端口，默认端口为6379</span></span>
<span class="line"><span># 如果指定0端口，表示Redis不监听TCP连接</span></span>
<span class="line"><span>port 6379</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 绑定的主机地址</span></span>
<span class="line"><span># 你可以绑定单一接口，如果没有绑定，所有接口都会监听到来的连接</span></span>
<span class="line"><span># bind 127.0.0.1</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Specify the path for the unix socket that will be used to listen for</span></span>
<span class="line"><span># incoming connections. There is no default, so Redis will not listen</span></span>
<span class="line"><span># on a unix socket when not specified.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># unixsocket /tmp/redis.sock</span></span>
<span class="line"><span># unixsocketperm 755</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span></span>
<span class="line"><span>timeout 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span></span>
<span class="line"><span># debug (很多信息, 对开发／测试比较有用)</span></span>
<span class="line"><span># verbose (many rarely useful info, but not a mess like the debug level)</span></span>
<span class="line"><span># notice (moderately verbose, what you want in production probably)</span></span>
<span class="line"><span># warning (only very important / critical messages are logged)</span></span>
<span class="line"><span>loglevel verbose</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 日志记录方式，默认为标准输出，如果配置为redis为守护进程方式运行，而这里又配置为标准输出，则日志将会发送给/dev/null</span></span>
<span class="line"><span>logfile stdout</span></span>
<span class="line"><span></span></span>
<span class="line"><span># To enable logging to the system logger, just set &#39;syslog-enabled&#39; to yes,</span></span>
<span class="line"><span># and optionally update the other syslog parameters to suit your needs.</span></span>
<span class="line"><span># syslog-enabled no</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Specify the syslog identity.</span></span>
<span class="line"><span># syslog-ident redis</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Specify the syslog facility.  Must be USER or between LOCAL0-LOCAL7.</span></span>
<span class="line"><span># syslog-facility local0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 设置数据库的数量，默认数据库为0，可以使用select &lt;dbid&gt;命令在连接上指定数据库id</span></span>
<span class="line"><span># dbid是从0到‘databases’-1的数目</span></span>
<span class="line"><span>databases 16</span></span>
<span class="line"><span></span></span>
<span class="line"><span>################################ SNAPSHOTTING  #################################</span></span>
<span class="line"><span># 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span></span>
<span class="line"><span># Save the DB on disk:</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span>#   save &lt;seconds&gt; &lt;changes&gt;</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span>#   Will save the DB if both the given number of seconds and the given</span></span>
<span class="line"><span>#   number of write operations against the DB occurred.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span>#   满足以下条件将会同步数据:</span></span>
<span class="line"><span>#   900秒（15分钟）内有1个更改</span></span>
<span class="line"><span>#   300秒（5分钟）内有10个更改</span></span>
<span class="line"><span>#   60秒内有10000个更改</span></span>
<span class="line"><span>#   Note: 可以把所有“save”行注释掉，这样就取消同步操作了</span></span>
<span class="line"><span></span></span>
<span class="line"><span>save 900 1</span></span>
<span class="line"><span>save 300 10</span></span>
<span class="line"><span>save 60 10000</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span></span>
<span class="line"><span>rdbcompression yes</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定本地数据库文件名，默认值为dump.rdb</span></span>
<span class="line"><span>dbfilename dump.rdb</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 工作目录.</span></span>
<span class="line"><span># 指定本地数据库存放目录，文件名由上一个dbfilename配置项指定</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># Also the Append Only File will be created inside this directory.</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># 注意，这里只能指定一个目录，不能指定文件名</span></span>
<span class="line"><span>dir ./</span></span>
<span class="line"><span></span></span>
<span class="line"><span>################################# REPLICATION #################################</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 主从复制。使用slaveof从 Redis服务器复制一个Redis实例。注意，该配置仅限于当前slave有效</span></span>
<span class="line"><span># so for example it is possible to configure the slave to save the DB with a</span></span>
<span class="line"><span># different interval, or to listen to another port, and so on.</span></span>
<span class="line"><span># 设置当本机为slav服务时，设置master服务的ip地址及端口，在Redis启动时，它会自动从master进行数据同步</span></span>
<span class="line"><span># slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 当master服务设置了密码保护时，slav服务连接master的密码</span></span>
<span class="line"><span># 下文的“requirepass”配置项可以指定密码</span></span>
<span class="line"><span># masterauth &lt;master-password&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># When a slave lost the connection with the master, or when the replication</span></span>
<span class="line"><span># is still in progress, the slave can act in two different ways:</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># 1) if slave-serve-stale-data is set to &#39;yes&#39; (the default) the slave will</span></span>
<span class="line"><span>#    still reply to client requests, possibly with out of data data, or the</span></span>
<span class="line"><span>#    data set may just be empty if this is the first synchronization.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># 2) if slave-serve-stale data is set to &#39;no&#39; the slave will reply with</span></span>
<span class="line"><span>#    an error &quot;SYNC with master in progress&quot; to all the kind of commands</span></span>
<span class="line"><span>#    but to INFO and SLAVEOF.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span>slave-serve-stale-data yes</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Slaves send PINGs to server in a predefined interval. It&#39;s possible to change</span></span>
<span class="line"><span># this interval with the repl_ping_slave_period option. The default value is 10</span></span>
<span class="line"><span># seconds.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># repl-ping-slave-period 10</span></span>
<span class="line"><span></span></span>
<span class="line"><span># The following option sets a timeout for both Bulk transfer I/O timeout and</span></span>
<span class="line"><span># master data or ping response timeout. The default value is 60 seconds.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># It is important to make sure that this value is greater than the value</span></span>
<span class="line"><span># specified for repl-ping-slave-period otherwise a timeout will be detected</span></span>
<span class="line"><span># every time there is low traffic between the master and the slave.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># repl-timeout 60</span></span>
<span class="line"><span></span></span>
<span class="line"><span>################################## SECURITY ###################################</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Warning: since Redis is pretty fast an outside user can try up to</span></span>
<span class="line"><span># 150k passwords per second against a good box. This means that you should</span></span>
<span class="line"><span># use a very strong password otherwise it will be very easy to break.</span></span>
<span class="line"><span># 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过auth &lt;password&gt;命令提供密码，默认关闭</span></span>
<span class="line"><span># requirepass foobared</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Command renaming.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># It is possilbe to change the name of dangerous commands in a shared</span></span>
<span class="line"><span># environment. For instance the CONFIG command may be renamed into something</span></span>
<span class="line"><span># of hard to guess so that it will be still available for internal-use</span></span>
<span class="line"><span># tools but not available for general clients.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># Example:</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># It is also possilbe to completely kill a command renaming it into</span></span>
<span class="line"><span># an empty string:</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># rename-command CONFIG &quot;&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>################################### LIMITS ####################################</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，</span></span>
<span class="line"><span># 如果设置maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max Number of clients reached错误信息</span></span>
<span class="line"><span># maxclients 128</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Don&#39;t use more memory than the specified amount of bytes.</span></span>
<span class="line"><span># When the memory limit is reached Redis will try to remove keys with an</span></span>
<span class="line"><span># EXPIRE set. It will try to start freeing keys that are going to expire</span></span>
<span class="line"><span># in little time and preserve keys with a longer time to live.</span></span>
<span class="line"><span># Redis will also try to remove objects from free lists if possible.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># If all this fails, Redis will start to reply with errors to commands</span></span>
<span class="line"><span># that will use more memory, like SET, LPUSH, and so on, and will continue</span></span>
<span class="line"><span># to reply to most read-only commands like GET.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># WARNING: maxmemory can be a good idea mainly if you want to use Redis as a</span></span>
<span class="line"><span># &#39;state&#39; server or cache, not as a real DB. When Redis is used as a real</span></span>
<span class="line"><span># database the memory usage will grow over the weeks, it will be obvious if</span></span>
<span class="line"><span># it is going to use too much memory in the long run, and you&#39;ll have the time</span></span>
<span class="line"><span># to upgrade. With maxmemory after the limit is reached you&#39;ll start to get</span></span>
<span class="line"><span># errors for write operations, and this may even lead to DB inconsistency.</span></span>
<span class="line"><span># 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，</span></span>
<span class="line"><span># 当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。</span></span>
<span class="line"><span># Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span></span>
<span class="line"><span># maxmemory &lt;bytes&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span></span>
<span class="line"><span># is reached? You can select among five behavior:</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># volatile-lru -&gt; remove the key with an expire set using an LRU algorithm</span></span>
<span class="line"><span># allkeys-lru -&gt; remove any key accordingly to the LRU algorithm</span></span>
<span class="line"><span># volatile-random -&gt; remove a random key with an expire set</span></span>
<span class="line"><span># allkeys-&gt;random -&gt; remove a random key, any key</span></span>
<span class="line"><span># volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)</span></span>
<span class="line"><span># noeviction -&gt; don&#39;t expire at all, just return an error on write operations</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># Note: with all the kind of policies, Redis will return an error on write</span></span>
<span class="line"><span>#       operations, when there are not suitable keys for eviction.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span>#       At the date of writing this commands are: set setnx setex append</span></span>
<span class="line"><span>#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span></span>
<span class="line"><span>#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span></span>
<span class="line"><span>#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span></span>
<span class="line"><span>#       getset mset msetnx exec sort</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># The default is:</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># maxmemory-policy volatile-lru</span></span>
<span class="line"><span></span></span>
<span class="line"><span># LRU and minimal TTL algorithms are not precise algorithms but approximated</span></span>
<span class="line"><span># algorithms (in order to save memory), so you can select as well the sample</span></span>
<span class="line"><span># size to check. For instance for default Redis will check three keys and</span></span>
<span class="line"><span># pick the one that was used less recently, you can change the sample size</span></span>
<span class="line"><span># using the following configuration directive.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># maxmemory-samples 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>############################## APPEND ONLY MODE ###############################</span></span>
<span class="line"><span></span></span>
<span class="line"><span># </span></span>
<span class="line"><span># Note that you can have both the async dumps and the append only file if you</span></span>
<span class="line"><span># like (you have to comment the &quot;save&quot; statements above to disable the dumps).</span></span>
<span class="line"><span># Still if append only mode is enabled Redis will load the data from the</span></span>
<span class="line"><span># log file at startup ignoring the dump.rdb file.</span></span>
<span class="line"><span># 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。</span></span>
<span class="line"><span># 因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span></span>
<span class="line"><span># IMPORTANT: Check the BGREWRITEAOF to check how to rewrite the append</span></span>
<span class="line"><span># log file in background when it gets too big.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>appendonly no</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定更新日志文件名，默认为appendonly.aof</span></span>
<span class="line"><span># appendfilename appendonly.aof</span></span>
<span class="line"><span></span></span>
<span class="line"><span># The fsync() call tells the Operating System to actually write data on disk</span></span>
<span class="line"><span># instead to wait for more data in the output buffer. Some OS will really flush </span></span>
<span class="line"><span># data on disk, some other OS will just try to do it ASAP.</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定更新日志条件，共有3个可选值：</span></span>
<span class="line"><span># no:表示等操作系统进行数据缓存同步到磁盘（快）</span></span>
<span class="line"><span># always:表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）</span></span>
<span class="line"><span># everysec:表示每秒同步一次（折衷，默认值）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>appendfsync everysec</span></span>
<span class="line"><span># appendfsync no</span></span>
<span class="line"><span></span></span>
<span class="line"><span># When the AOF fsync policy is set to always or everysec, and a background</span></span>
<span class="line"><span># saving process (a background save or AOF log background rewriting) is</span></span>
<span class="line"><span># performing a lot of I/O against the disk, in some Linux configurations</span></span>
<span class="line"><span># Redis may block too long on the fsync() call. Note that there is no fix for</span></span>
<span class="line"><span># this currently, as even performing fsync in a different thread will block</span></span>
<span class="line"><span># our synchronous write(2) call.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># In order to mitigate this problem it&#39;s possible to use the following option</span></span>
<span class="line"><span># that will prevent fsync() from being called in the main process while a</span></span>
<span class="line"><span># BGSAVE or BGREWRITEAOF is in progress.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># This means that while another child is saving the durability of Redis is</span></span>
<span class="line"><span># the same as &quot;appendfsync none&quot;, that in pratical terms means that it is</span></span>
<span class="line"><span># possible to lost up to 30 seconds of log in the worst scenario (with the</span></span>
<span class="line"><span># default Linux settings).</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span></span>
<span class="line"><span># &quot;no&quot; that is the safest pick from the point of view of durability.</span></span>
<span class="line"><span>no-appendfsync-on-rewrite no</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Automatic rewrite of the append only file.</span></span>
<span class="line"><span># Redis is able to automatically rewrite the log file implicitly calling</span></span>
<span class="line"><span># BGREWRITEAOF when the AOF log size will growth by the specified percentage.</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># This is how it works: Redis remembers the size of the AOF file after the</span></span>
<span class="line"><span># latest rewrite (or if no rewrite happened since the restart, the size of</span></span>
<span class="line"><span># the AOF at startup is used).</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># This base size is compared to the current size. If the current size is</span></span>
<span class="line"><span># bigger than the specified percentage, the rewrite is triggered. Also</span></span>
<span class="line"><span># you need to specify a minimal size for the AOF file to be rewritten, this</span></span>
<span class="line"><span># is useful to avoid rewriting the AOF file even if the percentage increase</span></span>
<span class="line"><span># is reached but it is still pretty small.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># Specify a precentage of zero in order to disable the automatic AOF</span></span>
<span class="line"><span># rewrite feature.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>auto-aof-rewrite-percentage 100</span></span>
<span class="line"><span>auto-aof-rewrite-min-size 64mb</span></span>
<span class="line"><span></span></span>
<span class="line"><span>################################## SLOW LOG ###################################</span></span>
<span class="line"><span></span></span>
<span class="line"><span># The Redis Slow Log is a system to log queries that exceeded a specified</span></span>
<span class="line"><span># execution time. The execution time does not include the I/O operations</span></span>
<span class="line"><span># like talking with the client, sending the reply and so forth,</span></span>
<span class="line"><span># but just the time needed to actually execute the command (this is the only</span></span>
<span class="line"><span># stage of command execution where the thread is blocked and can not serve</span></span>
<span class="line"><span># other requests in the meantime).</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># You can configure the slow log with two parameters: one tells Redis</span></span>
<span class="line"><span># what is the execution time, in microseconds, to exceed in order for the</span></span>
<span class="line"><span># command to get logged, and the other parameter is the length of the</span></span>
<span class="line"><span># slow log. When a new command is logged the oldest one is removed from the</span></span>
<span class="line"><span># queue of logged commands.</span></span>
<span class="line"><span></span></span>
<span class="line"><span># The following time is expressed in microseconds, so 1000000 is equivalent</span></span>
<span class="line"><span># to one second. Note that a negative number disables the slow log, while</span></span>
<span class="line"><span># a value of zero forces the logging of every command.</span></span>
<span class="line"><span>slowlog-log-slower-than 10000</span></span>
<span class="line"><span></span></span>
<span class="line"><span># There is no limit to this length. Just be aware that it will consume memory.</span></span>
<span class="line"><span># You can reclaim memory used by the slow log with SLOWLOG RESET.</span></span>
<span class="line"><span>slowlog-max-len 1024</span></span>
<span class="line"><span></span></span>
<span class="line"><span>################################ VIRTUAL MEMORY ###############################</span></span>
<span class="line"><span></span></span>
<span class="line"><span>### WARNING! Virtual Memory is deprecated in Redis 2.4</span></span>
<span class="line"><span>### The use of Virtual Memory is strongly discouraged.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>### WARNING! Virtual Memory is deprecated in Redis 2.4</span></span>
<span class="line"><span>### The use of Virtual Memory is strongly discouraged.</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Virtual Memory allows Redis to work with datasets bigger than the actual</span></span>
<span class="line"><span># amount of RAM needed to hold the whole dataset in memory.</span></span>
<span class="line"><span># In order to do so very used keys are taken in memory while the other keys</span></span>
<span class="line"><span># are swapped into a swap file, similarly to what operating systems do</span></span>
<span class="line"><span># with memory pages.</span></span>
<span class="line"><span># 指定是否启用虚拟内存机制，默认值为no，</span></span>
<span class="line"><span># VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中</span></span>
<span class="line"><span># 把vm-enabled设置为yes，根据需要设置好接下来的三个VM参数，就可以启动VM了</span></span>
<span class="line"><span>vm-enabled no</span></span>
<span class="line"><span># vm-enabled yes</span></span>
<span class="line"><span></span></span>
<span class="line"><span># This is the path of the Redis swap file. As you can guess, swap files</span></span>
<span class="line"><span># can&#39;t be shared by different Redis instances, so make sure to use a swap</span></span>
<span class="line"><span># file for every redis process you are running. Redis will complain if the</span></span>
<span class="line"><span># swap file is already in use.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># Redis交换文件最好的存储是SSD（固态硬盘）</span></span>
<span class="line"><span># 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span></span>
<span class="line"><span># *** WARNING *** if you are using a shared hosting the default of putting</span></span>
<span class="line"><span># the swap file under /tmp is not secure. Create a dir with access granted</span></span>
<span class="line"><span># only to Redis user and configure Redis to create the swap file there.</span></span>
<span class="line"><span>vm-swap-file /tmp/redis.swap</span></span>
<span class="line"><span></span></span>
<span class="line"><span># With vm-max-memory 0 the system will swap everything it can. Not a good</span></span>
<span class="line"><span># default, just specify the max amount of RAM you can in bytes, but it&#39;s</span></span>
<span class="line"><span># better to leave some margin. For instance specify an amount of RAM</span></span>
<span class="line"><span># that&#39;s more or less between 60 and 80% of your free RAM.</span></span>
<span class="line"><span># 将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多少，所有索引数据都是内存存储的（Redis的索引数据就是keys）</span></span>
<span class="line"><span># 也就是说当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为0</span></span>
<span class="line"><span>vm-max-memory 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的。</span></span>
<span class="line"><span># 建议如果存储很多小对象，page大小最后设置为32或64bytes；如果存储很大的对象，则可以使用更大的page，如果不确定，就使用默认值</span></span>
<span class="line"><span>vm-page-size 32</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 设置swap文件中的page数量由于页表（一种表示页面空闲或使用的bitmap）是存放在内存中的，在磁盘上每8个pages将消耗1byte的内存</span></span>
<span class="line"><span># swap空间总容量为 vm-page-size * vm-pages</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># With the default of 32-bytes memory pages and 134217728 pages Redis will</span></span>
<span class="line"><span># use a 4 GB swap file, that will use 16 MB of RAM for the page table.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># It&#39;s better to use the smallest acceptable value for your application,</span></span>
<span class="line"><span># but the default is large in order to work in most conditions.</span></span>
<span class="line"><span>vm-pages 134217728</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Max number of VM I/O threads running at the same time.</span></span>
<span class="line"><span># This threads are used to read/write data from/to swap file, since they</span></span>
<span class="line"><span># also encode and decode objects from disk to memory or the reverse, a bigger</span></span>
<span class="line"><span># number of threads can help with big objects even if they can&#39;t help with</span></span>
<span class="line"><span># I/O itself as the physical device may not be able to couple with many</span></span>
<span class="line"><span># reads/writes operations at the same time.</span></span>
<span class="line"><span># 设置访问swap文件的I/O线程数，最后不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟，默认值为4</span></span>
<span class="line"><span>vm-max-threads 4</span></span>
<span class="line"><span></span></span>
<span class="line"><span>############################### ADVANCED CONFIG ###############################</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Hashes are encoded in a special way (much more memory efficient) when they</span></span>
<span class="line"><span># have at max a given numer of elements, and the biggest element does not</span></span>
<span class="line"><span># exceed a given threshold. You can configure this limits with the following</span></span>
<span class="line"><span># configuration directives.</span></span>
<span class="line"><span># 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span></span>
<span class="line"><span>hash-max-zipmap-entries 512</span></span>
<span class="line"><span>hash-max-zipmap-value 64</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Similarly to hashes, small lists are also encoded in a special way in order</span></span>
<span class="line"><span># to save a lot of space. The special representation is only used when</span></span>
<span class="line"><span># you are under the following limits:</span></span>
<span class="line"><span>list-max-ziplist-entries 512</span></span>
<span class="line"><span>list-max-ziplist-value 64</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Sets have a special encoding in just one case: when a set is composed</span></span>
<span class="line"><span># of just strings that happens to be integers in radix 10 in the range</span></span>
<span class="line"><span># of 64 bit signed integers.</span></span>
<span class="line"><span># The following configuration setting sets the limit in the size of the</span></span>
<span class="line"><span># set in order to use this special memory saving encoding.</span></span>
<span class="line"><span>set-max-intset-entries 512</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Similarly to hashes and lists, sorted sets are also specially encoded in</span></span>
<span class="line"><span># order to save a lot of space. This encoding is only used when the length and</span></span>
<span class="line"><span># elements of a sorted set are below the following limits:</span></span>
<span class="line"><span>zset-max-ziplist-entries 128</span></span>
<span class="line"><span>zset-max-ziplist-value 64</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span></span>
<span class="line"><span># order to help rehashing the main Redis hash table (the one mapping top-level</span></span>
<span class="line"><span># keys to values). The hash table implementation redis uses (see dict.c)</span></span>
<span class="line"><span># performs a lazy rehashing: the more operation you run into an hash table</span></span>
<span class="line"><span># that is rhashing, the more rehashing &quot;steps&quot; are performed, so if the</span></span>
<span class="line"><span># server is idle the rehashing is never complete and some more memory is used</span></span>
<span class="line"><span># by the hash table.</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># The default is to use this millisecond 10 times every second in order to</span></span>
<span class="line"><span># active rehashing the main dictionaries, freeing memory when possible.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># If unsure:</span></span>
<span class="line"><span># use &quot;activerehashing no&quot; if you have hard latency requirements and it is</span></span>
<span class="line"><span># not a good thing in your environment that Redis can reply form time to time</span></span>
<span class="line"><span># to queries with 2 milliseconds delay.</span></span>
<span class="line"><span># 指定是否激活重置哈希，默认为开启</span></span>
<span class="line"><span>activerehashing yes</span></span>
<span class="line"><span></span></span>
<span class="line"><span>################################## INCLUDES ###################################</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定包含其他的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各实例又拥有自己的特定配置文件</span></span>
<span class="line"><span># include /path/to/local.conf</span></span>
<span class="line"><span># include /path/to/other.conf</span></span></code></pre></div>`,2)]))}const u=n(l,[["render",i]]);export{m as __pageData,u as default};
