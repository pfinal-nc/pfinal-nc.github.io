import{_ as i,c as a,o as n,a6 as t}from"./chunks/framework.BLq2o8be.js";const E=JSON.parse('{"title":"Python协程","description":"Python协程学习","frontmatter":{"title":"Python协程","date":"2023-04-07T09:28:47.000Z","tags":["python"],"description":"Python协程学习","author":"PFinal南丞","keywords":"Python, 协程, 并发, 编程, asyncio, 异步IO, Future, Task","head":[["meta",{"name":"keywords","content":"Python, 协程, 并发, 编程, asyncio, 异步IO, Future, Task"}]]},"headers":[],"relativePath":"zh/python/Python协程.md","filePath":"zh/python/Python协程.md","lastUpdated":1752052166000}'),l={name:"zh/python/Python协程.md"};function p(h,s,e,k,o,r){return n(),a("div",{"data-pagefind-body":!0},s[0]||(s[0]=[t(`<h1 id="python协程" tabindex="-1">Python协程 <a class="header-anchor" href="#python协程" aria-label="Permalink to &quot;Python协程&quot;">​</a></h1><h2 id="协程" tabindex="-1">协程 <a class="header-anchor" href="#协程" aria-label="Permalink to &quot;协程&quot;">​</a></h2><p>协程,又叫做微线程,他是一种用户态的轻量级线程.协程拥有自己的寄存器上下文和栈.调度切换时候,将寄存器上下文和栈保存在其他地方,在切换回来的时候,恢复先前保存的寄存器上下文和栈,因此 协程能保留上一次调用时的状态,即所有局部状态的一个特定组合,每次过程重入时,就相当于进入上一次调用的状态.</p><p>简单的协程实现:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutine_example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;start coroutine...name:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> yield</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#调用next()时，产出yield右边的值后暂停；调用send()时，产出值赋给x，并往下运行</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;send值:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">coro </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> coroutine_example(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;PFinal&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;next的返回值:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coro))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;send的返回值:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, coro.send(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>使用协程时需要预激活（next函数）后才能使用send发送值。(a = yield b)，next时会产出yield右边的值b，send时接收值的是yield左边的值a</p><p>Python 实现协主要是使用asyncio模块做异步IO</p><p>异步IO的asyncio库使用事件循环驱动的协程实现并发。用户可主动控制程序，在认为耗时IO处添加await（yield from）。在asyncio库中，协程使用@asyncio.coroutine装饰，使用yield from来驱动，@asyncio.coroutine -&gt; asyncyield from -&gt; await</p><h4 id="asyncio中重要概念" tabindex="-1">asyncio中重要概念 <a class="header-anchor" href="#asyncio中重要概念" aria-label="Permalink to &quot;asyncio中重要概念&quot;">​</a></h4><ol><li>事件循环</li></ol><blockquote><p>管理所有的事件，在整个程序运行过程中不断循环执行并追踪事件发生的顺序将它们放在队列中，空闲时调用相应的事件处理者来处理这些事件</p></blockquote><ol start="2"><li>Future</li></ol><blockquote><p>Future对象表示尚未完成的计算，还未完成的结果</p></blockquote><ol start="3"><li>Task</li></ol><blockquote><p>是Future的子类，作用是在运行某个任务的同时可以并发的运行多个任务。asyncio.Task用于实现协作式多任务的库，且Task对象不能用户手动实例化，通过2个函数创建：asyncio.async(), loop.create_task() 或 asyncio.ensure_future()</p></blockquote><p>如下定义一个协程:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># -*- coding: utf-8 -*-</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Time    : 2023/4/7 09:02</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Author  : PFinal南丞</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Email   : lampxiezi@163.com</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @File    : coroutine.py</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Software: PyCharm</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> asyncio</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Executing PFinal&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, )</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">coro </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> execute()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> asyncio.get_event_loop()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop.run_until_complete(coro)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop.close()</span></span></code></pre></div><blockquote><p>上面的代码中,使用 async 定义了一个 execute函数,直接调用了execute函数，然而execute函数并没有执行，而是返回了一个 coroutine 协程对象.随后使用 get_event_loop 方法创建了一个事件循环 loop,并调用了 loop 对象的 run_until_complete 方法将协程注册到事件循环 loop 中，然后启动.最后，才看到 execute 方法打印了输出结果。</p></blockquote><p>前面还提到了 task，它是对 coroutine 对象的进一步封装，比 coroutine 对象多了运行状态，比如 running、finished 等，可以用这些状态来获取协程对象的执行情况。代码如下:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># -*- coding: utf-8 -*-</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Time    : 2023/4/7 09:02</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Author  : PFinal南丞</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Email   : lampxiezi@163.com</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @File    : coroutine.py</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Software: PyCharm</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> asyncio</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Executing PFinal&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, )</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">coro </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> execute()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> asyncio.get_event_loop()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">task </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loop.create_task(coro)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Task&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, task)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop.run_until_complete(task)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Task&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, task)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># loop.close()</span></span></code></pre></div><p>运行结果:</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Task</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Task</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pending</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> name=&#39;Task-1&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Executing</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PFinal</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Task</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Task</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> finished</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> name=&#39;Task-1&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">进程已结束,退出代码0</span></span></code></pre></div><blockquote><p>上面代码,定义了 loop 对象之后，接着调用了它的 create_task 方法将 coroutine 对象转化为 task 对象，打印输出一下，发现它是 pending 状态。接着，将 task 对象添加到事件循环中执行，随后打印输出 task 对象，发现它的状态变成了 finished，同时还可以看到其 result 变成了 1，也就是定义的 execute 方法的返回结果。</p></blockquote>`,23)]))}const c=i(l,[["render",p]]);export{E as __pageData,c as default};
