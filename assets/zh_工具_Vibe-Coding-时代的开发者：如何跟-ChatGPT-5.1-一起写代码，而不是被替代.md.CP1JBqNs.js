import{_ as l,c as a,o as e,a6 as t}from"./chunks/framework.BwtyjzPT.js";const g=JSON.parse('{"title":"Vibe Coding 时代的开发者：如何跟 ChatGPT 5.1 一起写代码，而不是被替代","description":"在 Vibe Coding 时代，ChatGPT 5.1 已经坐在你的工位上了。这篇文章聊的不是“会不会被 AI 替代”，而是：如何和 ChatGPT 5.1 一起写代码，让它加班，你下班。","frontmatter":{"title":"Vibe Coding 时代的开发者：如何跟 ChatGPT 5.1 一起写代码，而不是被替代","date":"2025-11-28T00:00:00.000Z","author":"PFinal南丞","category":"工具","tags":["ai coding","chatgpt 5.1","vibe coding","developer productivity","software engineering"],"description":"在 Vibe Coding 时代，ChatGPT 5.1 已经坐在你的工位上了。这篇文章聊的不是“会不会被 AI 替代”，而是：如何和 ChatGPT 5.1 一起写代码，让它加班，你下班。","keywords":["vibe coding","chatgpt 5.1 coding","ai 写代码 实战","开发者 会不会被 ai 替代","ai 编程 工作流","chatgpt 辅助 编程","ai 代码 质量","ai 调试 难点","开发者 职业 焦虑 ai"],"head":[["link",{"rel":"canonical","href":"https://friday-go.icu/zh/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代"}],["link",{"rel":"alternate","hreflang":"zh-CN","href":"https://friday-go.icu/zh/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代"}],["link",{"rel":"alternate","hreflang":"en","href":"https://friday-go.icu/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代"}],["link",{"rel":"alternate","hreflang":"x-default","href":"https://friday-go.icu/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代"}],["meta",{"name":"keywords","content":"vibe coding,chatgpt 5.1 coding,ai 写代码 实战,开发者 会不会被 ai 替代,ai 编程 工作流,chatgpt 辅助 编程,ai 代码 质量,ai 调试 难点,开发者 职业 焦虑 ai, PFinalClub, Golang tutorial, Go backend development, Go microservices, PHP, Python, 技术博客, Tech Blog"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"TechArticle\\",\\"headline\\":\\"Vibe Coding 时代的开发者：如何跟 ChatGPT 5.1 一起写代码，而不是被替代\\",\\"url\\":\\"https://friday-go.icu/zh/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代\\",\\"datePublished\\":\\"2025-11-28T00:00:00.000Z\\",\\"dateModified\\":1764296363000,\\"author\\":{\\"@type\\":\\"Person\\",\\"name\\":\\"PFinal南丞\\",\\"url\\":\\"https://friday-go.icu/about\\"},\\"publisher\\":{\\"@type\\":\\"Organization\\",\\"name\\":\\"PFinalClub\\",\\"logo\\":{\\"@type\\":\\"ImageObject\\",\\"url\\":\\"https://friday-go.icu/logo.png\\"}},\\"description\\":\\"在 Vibe Coding 时代，ChatGPT 5.1 已经坐在你的工位上了。这篇文章聊的不是“会不会被 AI 替代”，而是：如何和 ChatGPT 5.1 一起写代码，让它加班，你下班。\\",\\"inLanguage\\":\\"zh-CN\\",\\"mainEntityOfPage\\":{\\"@type\\":\\"WebPage\\",\\"@id\\":\\"https://friday-go.icu/zh/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代\\"},\\"keywords\\":[\\"vibe coding\\",\\"chatgpt 5.1 coding\\",\\"ai 写代码 实战\\",\\"开发者 会不会被 ai 替代\\",\\"ai 编程 工作流\\",\\"chatgpt 辅助 编程\\",\\"ai 代码 质量\\",\\"ai 调试 难点\\",\\"开发者 职业 焦虑 ai\\"],\\"articleSection\\":\\"工具\\"}"]]},"headers":[],"relativePath":"zh/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代.md","filePath":"zh/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代.md","lastUpdated":1764296363000}'),o={name:"zh/工具/Vibe-Coding-时代的开发者：如何跟-ChatGPT-5.1-一起写代码，而不是被替代.md"};function r(n,i,p,h,d,u){return e(),a("div",{"data-pagefind-body":!0,"data-pagefind-meta":"date:1764288000000"},i[0]||(i[0]=[t('<h1 id="vibe-coding-时代的开发者-如何跟-chatgpt-5-1-一起写代码-而不是被替代" tabindex="-1">Vibe Coding 时代的开发者：如何跟 ChatGPT 5.1 一起写代码，而不是被替代 <a class="header-anchor" href="#vibe-coding-时代的开发者-如何跟-chatgpt-5-1-一起写代码-而不是被替代" aria-label="Permalink to &quot;Vibe Coding 时代的开发者：如何跟 ChatGPT 5.1 一起写代码，而不是被替代&quot;">​</a></h1><blockquote><p>你有没有这种体验：IDE 里一行代码都没敲，任务已经“完成 80%”；<br> 结果线上一挂，leader 问是谁写的，你看着屏幕沉默不语：<br> “不能说完全不是我写的，只能说大部分不是我写的。”</p></blockquote><p>欢迎来到 <strong>Vibe Coding 时代</strong>。<br> 键盘声越来越少，prompt 越来越长，Bug 依然如约而至。</p><p>这篇文章不聊“AI 会不会抢程序员饭碗”这种宏大问题，只聊一件更现实的事：</p><blockquote><p><strong>既然 ChatGPT 5.1 已经坐在你工位上了，你怎么跟它一起干活，<br> 让它加班，让你下班，而不是反过来。</strong></p></blockquote><hr><h2 id="一、先说清楚-什么是-vibe-coding" tabindex="-1">一、先说清楚：什么是 Vibe Coding？ <a class="header-anchor" href="#一、先说清楚-什么是-vibe-coding" aria-label="Permalink to &quot;一、先说清楚：什么是 Vibe Coding？&quot;">​</a></h2><p>Vibe Coding 这玩意，本质上就一句话：</p><blockquote><p><strong>“我不想在语法细节里打转，我只想描述我要什么，然后看着 AI 把代码敲出来。”</strong></p></blockquote><p>再配上：</p><ul><li>一点 Lofi 音乐</li><li>一块超宽屏</li><li>两盏氛围灯</li><li>一杯装在马克杯里的某种液体（咖啡 / 茶 / 功能饮料 / 柠檬水都行）</li></ul><p>你就拥有了社交媒体意义上的——<strong>“认真写代码的一天”</strong>。</p><p>技术视角下，它其实是三件事叠加：</p><ul><li><strong>自然语言建模</strong>：用中文 / 英文描述需求、约束、边界条件</li><li><strong>AI 代码生成</strong>：ChatGPT 5.1 / Copilot / 其他 LLM 把它翻译成代码</li><li><strong>人类审计与重构</strong>：你来决定哪些能用，哪些必须砍掉重写</li></ul><p>如果你只做前两步，不做第三步，那不叫 Vibe Coding，叫 <strong>Vibe Gambling</strong>。</p><hr><h2 id="二、最常见的翻车现场-不是-ai-太蠢-是你太相信它" tabindex="-1">二、最常见的翻车现场：不是 AI 太蠢，是你太相信它 <a class="header-anchor" href="#二、最常见的翻车现场-不是-ai-太蠢-是你太相信它" aria-label="Permalink to &quot;二、最常见的翻车现场：不是 AI 太蠢，是你太相信它&quot;">​</a></h2><p>聊怎么用之前，先看几个大家普遍遇到的坑。读着读着，如果你觉得“怎么这么眼熟”，说明你已经深度体验过了。</p><h3 id="_1-看起来很对-就是跑不起来" tabindex="-1">1. “看起来很对，就是跑不起来” <a class="header-anchor" href="#_1-看起来很对-就是跑不起来" aria-label="Permalink to &quot;1. “看起来很对，就是跑不起来”&quot;">​</a></h3><p>典型现象：</p><ul><li>本地一跑，能过 happy path；</li><li>真上测试环境，一堆边界条件全炸；</li><li>出了问题往下翻代码，发现一半逻辑你压根没细看过。</li></ul><p>原因很简单：</p><ul><li>传统开发是：<strong>“写代码 → 自己理解”</strong>；</li><li>Vibe Coding 很容易变成：<strong>“AI 生成 → 大致扫一眼 → 直接 copy”</strong>。</li></ul><p>人类天生不擅长做“只看结果不看过程”的审计工作，尤其是几百行一坨的时候。</p><h3 id="_2-调试体验-像在给陌生人免费加班" tabindex="-1">2. 调试体验：像在给陌生人免费加班 <a class="header-anchor" href="#_2-调试体验-像在给陌生人免费加班" aria-label="Permalink to &quot;2. 调试体验：像在给陌生人免费加班&quot;">​</a></h3><p>以前 debug 是在跟“过去的自己”对话：</p><blockquote><p>“我当时为什么这么写？哦原来是为了 xxx。”</p></blockquote><p>现在 debug 更像在翻别人 GitHub 仓库：</p><ul><li>命名风格和你完全不一样</li><li>错误处理哲学跟你团队约定完全相反</li><li>日志要么没有，要么一股“教学示例味”</li></ul><p>你不是不会 debug，你只是不认识这个写代码的人——而那个人叫 ChatGPT。</p><h3 id="_3-demo-非常丝滑-上生产惨不忍睹" tabindex="-1">3. Demo 非常丝滑，上生产惨不忍睹 <a class="header-anchor" href="#_3-demo-非常丝滑-上生产惨不忍睹" aria-label="Permalink to &quot;3. Demo 非常丝滑，上生产惨不忍睹&quot;">​</a></h3><p>Vibe Coding 特别擅长：</p><ul><li>写 demo</li><li>录视频</li><li>写博客里的代码片段</li></ul><p>但线上服务需要的是：</p><ul><li><strong>可观测性</strong>（日志、指标、Trace 一条龙）</li><li><strong>一致的错误处理策略</strong></li><li><strong>性能与资源使用的边界</strong></li></ul><p>这些东西，ChatGPT 5.1 不是写不出来，而是——<strong>你不提醒，它也不会主动上心。</strong></p><hr><h2 id="三、重新分工-你当导演和架构师-chatgpt-5-1-当高级工具人" tabindex="-1">三、重新分工：你当导演和架构师，ChatGPT 5.1 当高级工具人 <a class="header-anchor" href="#三、重新分工-你当导演和架构师-chatgpt-5-1-当高级工具人" aria-label="Permalink to &quot;三、重新分工：你当导演和架构师，ChatGPT 5.1 当高级工具人&quot;">​</a></h2><p>想跟 5.1 长期和平共处，核心是换一套身份认知：</p><blockquote><p><strong>别把自己当“写代码的人”，而是当“组织智能的人”。</strong></p></blockquote><p>听起来有点玄？直接给一套可以明天就试的工作流。</p><h3 id="_1-先别让它写代码-先让它-打草稿" tabindex="-1">1. 先别让它写代码，先让它“打草稿” <a class="header-anchor" href="#_1-先别让它写代码-先让它-打草稿" aria-label="Permalink to &quot;1. 先别让它写代码，先让它“打草稿”&quot;">​</a></h3><p>无论是 Go / PHP / TypeScript，都可以这样来：</p><ol><li><p><strong>写清楚上下文和约束</strong>，包括但不限于：</p><ul><li>项目结构（单体 / 微服务 / Monorepo）</li><li>错误处理约定（是否统一 wrap、是否用统一中间件处理）</li><li>日志方案（用什么库、日志级别、字段规范）</li></ul></li><li><p>然后对 5.1 说：<br><strong>“先别写实现，先帮我列：模块切分 / 结构体设计 / 接口定义 / 错误类型设计。”</strong></p></li><li><p>你做的事只有一件：<br><strong>在这个“结构草稿”上疯狂批注</strong>：</p><ul><li>这里太复杂了，拆简单点</li><li>这里要考虑幂等</li><li>这里需要预留熔断 / 重试</li><li>这里未来可能会拆成独立服务</li></ul></li></ol><p>这一步的思路是：</p><blockquote><p>让 5.1 把你脑子里的想法拉成“白板草图”，而不是直接生成 500 行成品。</p></blockquote><h3 id="_2-按模块生成-而不是-一口气全写完" tabindex="-1">2. 按模块生成，而不是“一口气全写完” <a class="header-anchor" href="#_2-按模块生成-而不是-一口气全写完" aria-label="Permalink to &quot;2. 按模块生成，而不是“一口气全写完”&quot;">​</a></h3><p>等结构你认可之后，再按模块下指令：</p><ul><li>“现在只实现 <code>UserRepository</code>，要求：……”</li><li>“帮我写这部分的单元测试，覆盖这几种失败场景……”</li><li>“把错误处理统一改成我们项目里的风格：wrapped error + 统一中间件……”</li></ul><p>每次生成代码，都让 5.1 带上：</p><ul><li>简单的注释</li><li>失败路径的处理</li><li>一小段“自我审查”，例如： <ul><li>这段代码有哪些潜在风险？</li><li>如果把并发量放大 10 倍会怎样？</li><li>哪些地方最可能出 bug？</li></ul></li></ul><p>你要做的，不是盯着每一行语法，而是看：</p><ul><li>结构有没有踩你团队的禁区</li><li>有没有一看就不舒服的地方（抽象过度 / 分层过细 / 命名别扭）</li></ul><h3 id="_3-最关键的一步-让-5-1-给自己挑刺" tabindex="-1">3. 最关键的一步：让 5.1 给自己挑刺 <a class="header-anchor" href="#_3-最关键的一步-让-5-1-给自己挑刺" aria-label="Permalink to &quot;3. 最关键的一步：让 5.1 给自己挑刺&quot;">​</a></h3><p>这一步很多人压根没用过，但效果非常好：</p><blockquote><p>“请你用严苛 code review 的标准，审查一下你刚才写的这段代码，从</p><ul><li>可读性</li><li>性能</li><li>错误处理</li><li>日志 &amp; 可观测性<br> 这四个方面指出问题，并给出更好的版本。”</li></ul></blockquote><p>你会发现：<strong>同一个 5.1，认真起来和敷衍的时候，代码完全不是一个水平。</strong></p><p>你的工作变成：</p><ul><li>在两版之间做 trade-off</li><li>决定是“稍微复杂但是健壮”，还是“简单一点但可接受”</li></ul><hr><h2 id="四、我会不会被-更会用-5-1-的人-替代" tabindex="-1">四、我会不会被“更会用 5.1 的人”替代？ <a class="header-anchor" href="#四、我会不会被-更会用-5-1-的人-替代" aria-label="Permalink to &quot;四、我会不会被“更会用 5.1 的人”替代？&quot;">​</a></h2><p>坦白讲，会有一部分人被替代，但不是因为 5.1，而是因为：</p><blockquote><p>他既不会写好代码，也不会用好 5.1。</p></blockquote><p>我们可以把开发者粗暴地分成三种：</p><h3 id="_1-只会手写代码-但拒绝用-ai-的" tabindex="-1">1. 只会手写代码，但拒绝用 AI 的 <a class="header-anchor" href="#_1-只会手写代码-但拒绝用-ai-的" aria-label="Permalink to &quot;1. 只会手写代码，但拒绝用 AI 的&quot;">​</a></h3><ul><li>优点：基本功扎实</li><li>缺点：产出速度会被彻底碾压</li><li>未来角色：可能会在“极端可靠领域”继续有需求（内核、安全、极高性能场景），但数量有限</li></ul><h3 id="_2-只会写-prompt-不懂工程和架构的" tabindex="-1">2. 只会写 prompt，不懂工程和架构的 <a class="header-anchor" href="#_2-只会写-prompt-不懂工程和架构的" aria-label="Permalink to &quot;2. 只会写 prompt，不懂工程和架构的&quot;">​</a></h3><ul><li>优点：前期看起来产能很高</li><li>缺点：项目一大就会崩盘，Bug / 技债 / 运维压力全找上门</li><li>未来角色：会被下一代工具替代，因为任何人都能写“差不多的 prompt”</li></ul><h3 id="_3-既懂工程-又会-orchestrate-ai-的" tabindex="-1">3. 既懂工程，又会 orchestrate AI 的 <a class="header-anchor" href="#_3-既懂工程-又会-orchestrate-ai-的" aria-label="Permalink to &quot;3. 既懂工程，又会 orchestrate AI 的&quot;">​</a></h3><p>他们会做的事包括：</p><ul><li>能把需求拆成合理的模块和边界</li><li>知道哪些适合交给 5.1，哪些必须自己写</li><li>知道如何审计 5.1 的输出，让它为你的架构服务</li></ul><p>未来，这些人更像是“<strong>放大器</strong>”：</p><ul><li>一个人可以顶过去三五个纯手工开发的产出</li><li>他们不是在跟 AI 竞争，而是在用 AI 放大自己的判断力</li></ul><p>你想成为哪一类，大概率是可以自己选的。</p><hr><h2 id="五、在-vibe-coding-时代-怎么保住-硬功夫" tabindex="-1">五、在 Vibe Coding 时代，怎么保住“硬功夫”？ <a class="header-anchor" href="#五、在-vibe-coding-时代-怎么保住-硬功夫" aria-label="Permalink to &quot;五、在 Vibe Coding 时代，怎么保住“硬功夫”？&quot;">​</a></h2><p>既然我们承认要和 5.1 合作，那“别被替代”就不是靠拒绝使用，而是靠：</p><blockquote><p>在 AI 极擅长的地方借力，在 AI 不擅长的地方补位。</p></blockquote><p>换句话说：<strong>该让它做的让它做，该你硬上的别躲。</strong></p><p>给你几个简单可执行的习惯：</p><h3 id="_1-每周保持一段-纯手写时间" tabindex="-1">1. 每周保持一段“纯手写时间” <a class="header-anchor" href="#_1-每周保持一段-纯手写时间" aria-label="Permalink to &quot;1. 每周保持一段“纯手写时间”&quot;">​</a></h3><p>不用太长，30–60 分钟就行。<br> 可以做这些事：</p><ul><li>手写一个常见数据结构 / 算法</li><li>重构一段老代码，不借助 AI，让自己重新走一遍决策路径</li><li>为现有项目写一份“设计说明书”或 README 的架构部分</li></ul><p>这段时间的目标不是“提高效率”，而是<strong>给大脑做力量训练</strong>。</p><h3 id="_2-每次用-5-1-都让它-解释一下为什么这么写" tabindex="-1">2. 每次用 5.1，都让它“解释一下为什么这么写” <a class="header-anchor" href="#_2-每次用-5-1-都让它-解释一下为什么这么写" aria-label="Permalink to &quot;2. 每次用 5.1，都让它“解释一下为什么这么写”&quot;">​</a></h3><p>比如：</p><ul><li>“请用架构师角度解释一下，你为什么这样划分模块？”</li><li>“如果改用事件驱动 / CQRS / 另一种模式，会发生什么变化？”</li><li>“这段实现里，哪部分最脆弱，最值得写测试？”</li></ul><p>你会得到一段“教材式解释”。<br> 这段解释，比那几百行代码更值钱。</p><h3 id="_3-故意跟它-唱反调-一两次" tabindex="-1">3. 故意跟它“唱反调”一两次 <a class="header-anchor" href="#_3-故意跟它-唱反调-一两次" aria-label="Permalink to &quot;3. 故意跟它“唱反调”一两次&quot;">​</a></h3><p>当 5.1 给你一个方案时，主动问：</p><ul><li>“给我一个完全相反风格的实现，比如从 OOP 改成偏函数式风格。”</li><li>“如果我不允许使用某个第三方库，你会怎么改？”</li></ul><p>你会开始学会 <strong>比较方案，而不是被第一个答案牵着走</strong>。<br> 慢慢地，你会发现自己在做的，其实已经是架构设计而不是简单“写代码”。</p><hr><h2 id="六、别忘了-安全、可观测性和规范-依然是你的锅" tabindex="-1">六、别忘了：安全、可观测性和规范，依然是你的锅 <a class="header-anchor" href="#六、别忘了-安全、可观测性和规范-依然是你的锅" aria-label="Permalink to &quot;六、别忘了：安全、可观测性和规范，依然是你的锅&quot;">​</a></h2><p>无论 5.1 写了多少代码，有三件事永远写在你名字上：</p><ul><li><strong>安全</strong>：有没有把 token 写在代码里，有没有做输入校验</li><li><strong>可观测性</strong>：出了问题你追不追得到</li><li><strong>团队规范</strong>：代码风格、错误处理、日志标准</li></ul><p>给一套“最小自查清单”，你可以直接贴进项目里：</p><ul><li>所有外部调用： <ul><li>是否有超时与重试策略？</li><li>失败时是否打点 / 记日志？</li></ul></li><li>错误处理： <ul><li>是否统一 wrap / 分类？</li><li>是否会在边界层（HTTP / RPC）归一化？</li></ul></li><li>日志： <ul><li>是否包含 trace id / request id？</li><li>是否避免在日志里打出敏感信息？</li></ul></li></ul><p>你完全可以让 5.1 来帮你写这张清单、甚至自动检查一遍代码，<br> 但<strong>勾不勾选，是你的责任</strong>。</p><hr><h2 id="七、vibe-coding-时代-最好的位置在哪里" tabindex="-1">七、Vibe Coding 时代，最好的位置在哪里？ <a class="header-anchor" href="#七、vibe-coding-时代-最好的位置在哪里" aria-label="Permalink to &quot;七、Vibe Coding 时代，最好的位置在哪里？&quot;">​</a></h2><p>如果把软件开发流程粗暴拆开，大致是这样：</p><blockquote><p>需求 → 架构 &amp; 设计 → 编码 &amp; 测试 → 部署 &amp; 监控 → 运营 &amp; 迭代</p></blockquote><p>Vibe Coding 和 ChatGPT 5.1，目前最厉害的是这几个环节：</p><ul><li>编码：大量样板代码、胶水代码、CRUD</li><li>测试：生成测试用例、mock、简单集成测试脚手架</li><li>文档：接口文档、使用说明、CHANGELOG 草稿</li></ul><p>而最不容易被替代的是：</p><ul><li><strong>需求拆解</strong>：你到底要解决什么问题</li><li><strong>架构折中</strong>：在复杂度 / 性能 / 成本 / 上线时间之间做平衡</li><li><strong>工程规范与团队文化</strong>：<br> 同样的 AI 工具，在你手上和别人手上，产物差距会非常大</li></ul><p>所以，这篇文章真正想说的一句话是：</p><blockquote><p>别再纠结“会不会写代码会被替代”，<br> 把精力放在“如何更好地组织智能”——包括你自己和 ChatGPT 5.1。</p></blockquote><hr><h2 id="八、小结-明天就可以尝试的-3-个小实验" tabindex="-1">八、小结：明天就可以尝试的 3 个小实验 <a class="header-anchor" href="#八、小结-明天就可以尝试的-3-个小实验" aria-label="Permalink to &quot;八、小结：明天就可以尝试的 3 个小实验&quot;">​</a></h2><p>如果你看到这里，可以试试下面三件小事：</p><h3 id="实验-1-只让-5-1-画草图" tabindex="-1">实验 1：只让 5.1 画草图 <a class="header-anchor" href="#实验-1-只让-5-1-画草图" aria-label="Permalink to &quot;实验 1：只让 5.1 画草图&quot;">​</a></h3><p>找一个你准备写的新功能，禁止它直接写实现，只让它列：</p><ul><li>模块划分</li><li>接口定义</li><li>数据结构设计</li><li>错误类型设计</li></ul><p>你在上面批注，感受一下自己从“码农”变成“导演”的过程。</p><h3 id="实验-2-请-5-1-做一次-严厉的-code-reviewer" tabindex="-1">实验 2：请 5.1 做一次“严厉的 code reviewer” <a class="header-anchor" href="#实验-2-请-5-1-做一次-严厉的-code-reviewer" aria-label="Permalink to &quot;实验 2：请 5.1 做一次“严厉的 code reviewer”&quot;">​</a></h3><p>把你最近写的（或它写的）一段核心代码扔给它，让它从：</p><ul><li>可读性</li><li>性能</li><li>错误处理</li><li>日志 &amp; 可观测性</li></ul><p>这四个维度挑刺并重写一版。你只做一件事：<br><strong>挑你喜欢的部分 merge 回项目。</strong></p><h3 id="实验-3-给未来的自己写一封-使用说明" tabindex="-1">实验 3：给未来的自己写一封“使用说明” <a class="header-anchor" href="#实验-3-给未来的自己写一封-使用说明" aria-label="Permalink to &quot;实验 3：给未来的自己写一封“使用说明”&quot;">​</a></h3><p>用自然语言写下：</p><ul><li>你希望项目里的错误处理长什么样</li><li>你接受 / 不接受哪些快捷方式</li><li>哪些“为了赶上线的妥协”，未来必须还债</li></ul><p>然后把这封“说明书”交给 ChatGPT 5.1，让它以后都按这个标准来生成代码。</p><p>当你开始这样用 ChatGPT 5.1 的时候，你就已经从：</p><ul><li>“担心被替代的那一拨人”，</li></ul><p>缓缓走向：</p><ul><li>“把 AI 当成增幅器的那一拨人”。</li></ul><p>Vibe 可以继续，Coding 也要硬。<br> 能一起弹琴的，才配一起 Vibe。</p>',129)]))}const c=l(o,[["render",r]]);export{g as __pageData,c as default};
