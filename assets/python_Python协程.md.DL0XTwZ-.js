import{_ as i,c as a,o as n,a6 as l}from"./chunks/framework.B5rgnJXo.js";const d=JSON.parse('{"title":"Python协程","description":"Python协程学习","frontmatter":{"title":"Python协程","date":"2023-04-07T09:28:47.000Z","tags":["python"],"description":"Python协程学习","author":"PFinal南丞","keywords":"Python, 协程, 并发, 编程, asyncio, 异步IO, Future, Task,Python, 网站, 搜集, 资源, 开发, 编程, 工具, 镜像站, 爬虫,Python版本管理神器之pyenv, python, 工具, python版本管理, pyenv使用教程, python环境配置,爬虫, 加密, 解密, 算法, 特征, 收集,爬虫JS逆向Webpack技巧记录, 爬虫, JS, Webpack,爬虫, 加密, 解密, 算法, 特征, 收集,Composer, 配置文件, 依赖管理, 包管理, 版本控制,PHP, $_SERVER,PHP, 会话, 引发, Bug, PHP_SESSION, $_SESSION, 会话管理,PHP, 生成器, 解析, PHP生成器, PHP生成器解析, PHP生成器解析,PHP, 错误与异常处理, 异常, 错误, 处理, 异常处理, 错误处理, 程序, 健壮性, 稳定性,golang, gopsutil, 系统库, 监控, 系统信息, 进程, 进程监控, 系统信息获取,使用Go实现服务端事件推送SSE, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,用Wails和Vue.js打造跨平台桌面应用程序, Wails, Vue.js, 跨平台桌面应用程序, 抖音, 直播,基于Wails的Mac桌面应用开发, golang, Wails, 桌面应用, 开发,基于Wails的抖音直播工具, golang, Wails, 抖音, 直播, 工具, 桌面应用,golang, 游戏开发, 接口设计, 高性能, 高并发, 游戏服务器, 游戏接口, 游戏框架,Wails, 应用, 开发, 尝试, 桌面应用, Go, Web开发, Tailwindcss, sqlite,Go-Cache, Wails, 内存缓存, 性能优化, 缓存策略, 内存管理, 应用程序性能,golang, 工具, 提升生产力, 开发, golang, Go开发, Go工具, Go扩展包,提速利器：使用Go语言实现静态化API, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,深入Go内存分配, golang, 内存分配,Go Channel, 批量读取, 实际应用,Laravel, 构建, 手工, 框架, 手工构建, PHP,Laravel, Carbon, 类, 使用, Laravel-Carbon-类使用, Laravel-Carbon-类使用解析,PHP, 进程, 线程, 解析, PHP进程, PHP线程, PHP进程线程, PHP进程线程解析, PHP进程线程解析,golang, TLS, SSL, 网络安全, 传输层安全协议, 安全套接层, 加密, 数据传输, 网络通信,Golang, 协程池, 实现, 方法, 协程, 池, 概念, 应用, 场景, 实现方式, 协程池功能, 性能, 响应速度,golang, 脱敏扩展包：简化敏感信息处理的利器, 工具, golang扩展包, golang脱敏, golang脱敏工具,Golang, 工具, 效率, 提升, 小工具, 代码质量, 开发, 编程, 工具, 自动格式化, 自动导入, 代码补全,undefined,AutoCorrent专有名词大小写扩展包, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,Create Go App CLI, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,Go语言开发终端小工具后续, Go, 工具, 终端, 小工具, 开发, 编程, 命令, 工具开发, 代码实现, 运行命令,GO开发IP过滤小脚本, go, 工具, go开发ip过滤, go ip过滤脚本, go ip过滤,Go 开发终端小工具, golang, 工具, 开发, 编程, 终端, 天气查询, 手机归属地查询, cobra库, 命令行小工具,Go语言的高性能User-Agent解析库, golang, 工具, User-Agent解析, 性能测试, 解析库,golang, 地址生成, 扩展包, 地理位置, 中国地址, 地址生成工具, 地址数据, 地址库,Gomail邮件发送包, golang, 工具, 邮件发送, 邮件接收, 邮件发送包, 邮件发送工具,Go, URL检测, 工具, 编程, 终端命令, 开发, 检测, 小工具, 终端命令小工具, Go终端命令小工具,Go语言安全库使用指南, Go语言, 安全库, 使用指南, crypto, encoding, hash, math, rand, strconv, time,Go语言实现守护进程, 守护进程, 技术详解, Go语言, 进程管理, 关键技术点,Go, 并发, 模式, 编程, 并发编程, Go语言, 并发模式, 并发实战, 并发指南,go:embed 在 Go 开发中的应用与最佳实践, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,Golang, Web应用, 安全指南, 输入验证, 输出编码, 会话管理, 文件上传, 跨站脚本攻击, SQL注入, 密码存储, 身份验证, 授权, 安全配置, 日志记录, 错误处理, 性能优化, 安全审计,pfinalclub, git, gitsite, javascript, node, jquery, python, php, laravel, sql, database, linux, operating system, os, cpu, verilog, risc-v, bitcoin, ethereum, ai, 教程, 软件, 编程, 开发, 运维, 云计算, 网络, 互联网, 比特币, 以太坊, 操作系统, 智能合约, 数字货币, 爬虫, 逆向"},"headers":[],"relativePath":"python/Python协程.md","filePath":"python/Python协程.md","lastUpdated":1741944848000}'),t={name:"python/Python协程.md"};function p(e,s,h,k,o,r){return n(),a("div",{"data-pagefind-body":!0},s[0]||(s[0]=[l(`<h1 id="python协程" tabindex="-1">Python协程 <a class="header-anchor" href="#python协程" aria-label="Permalink to &quot;Python协程&quot;">​</a></h1><h2 id="协程" tabindex="-1">协程 <a class="header-anchor" href="#协程" aria-label="Permalink to &quot;协程&quot;">​</a></h2><p>协程,又叫做微线程,他是一种用户态的轻量级线程.协程拥有自己的寄存器上下文和栈.调度切换时候,将寄存器上下文和栈保存在其他地方,在切换回来的时候,恢复先前保存的寄存器上下文和栈,因此 协程能保留上一次调用时的状态,即所有局部状态的一个特定组合,每次过程重入时,就相当于进入上一次调用的状态.</p><p>简单的协程实现:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> coroutine_example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;start coroutine...name:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> yield</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#调用next()时，产出yield右边的值后暂停；调用send()时，产出值赋给x，并往下运行</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;send值:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">coro </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> coroutine_example(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;PFinal&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;next的返回值:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coro))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;send的返回值:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, coro.send(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>使用协程时需要预激活（next函数）后才能使用send发送值。(a = yield b)，next时会产出yield右边的值b，send时接收值的是yield左边的值a</p><p>Python 实现协主要是使用asyncio模块做异步IO</p><p>异步IO的asyncio库使用事件循环驱动的协程实现并发。用户可主动控制程序，在认为耗时IO处添加await（yield from）。在asyncio库中，协程使用@asyncio.coroutine装饰，使用yield from来驱动，@asyncio.coroutine -&gt; asyncyield from -&gt; await</p><h4 id="asyncio中重要概念" tabindex="-1">asyncio中重要概念 <a class="header-anchor" href="#asyncio中重要概念" aria-label="Permalink to &quot;asyncio中重要概念&quot;">​</a></h4><ol><li>事件循环</li></ol><blockquote><p>管理所有的事件，在整个程序运行过程中不断循环执行并追踪事件发生的顺序将它们放在队列中，空闲时调用相应的事件处理者来处理这些事件</p></blockquote><ol start="2"><li>Future</li></ol><blockquote><p>Future对象表示尚未完成的计算，还未完成的结果</p></blockquote><ol start="3"><li>Task</li></ol><blockquote><p>是Future的子类，作用是在运行某个任务的同时可以并发的运行多个任务。asyncio.Task用于实现协作式多任务的库，且Task对象不能用户手动实例化，通过2个函数创建：asyncio.async(), loop.create_task() 或 asyncio.ensure_future()</p></blockquote><p>如下定义一个协程:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># -*- coding: utf-8 -*-</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Time    : 2023/4/7 09:02</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Author  : PFinal南丞</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Email   : lampxiezi@163.com</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @File    : coroutine.py</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Software: PyCharm</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> asyncio</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Executing PFinal&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, )</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">coro </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> execute()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> asyncio.get_event_loop()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop.run_until_complete(coro)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop.close()</span></span></code></pre></div><blockquote><p>上面的代码中,使用 async 定义了一个 execute函数,直接调用了execute函数，然而execute函数并没有执行，而是返回了一个 coroutine 协程对象.随后使用 get_event_loop 方法创建了一个事件循环 loop,并调用了 loop 对象的 run_until_complete 方法将协程注册到事件循环 loop 中，然后启动.最后，才看到 execute 方法打印了输出结果。</p></blockquote><p>前面还提到了 task，它是对 coroutine 对象的进一步封装，比 coroutine 对象多了运行状态，比如 running、finished 等，可以用这些状态来获取协程对象的执行情况。代码如下:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># -*- coding: utf-8 -*-</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Time    : 2023/4/7 09:02</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Author  : PFinal南丞</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Email   : lampxiezi@163.com</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @File    : coroutine.py</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># @Software: PyCharm</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> asyncio</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Executing PFinal&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, )</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">coro </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> execute()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> asyncio.get_event_loop()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">task </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loop.create_task(coro)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Task&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, task)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop.run_until_complete(task)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Task&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, task)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># loop.close()</span></span></code></pre></div><p>运行结果:</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Task</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Task</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pending</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> name=&#39;Task-1&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Executing</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PFinal</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Task</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Task</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> finished</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> name=&#39;Task-1&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">进程已结束,退出代码0</span></span></code></pre></div><blockquote><p>上面代码,定义了 loop 对象之后，接着调用了它的 create_task 方法将 coroutine 对象转化为 task 对象，打印输出一下，发现它是 pending 状态。接着，将 task 对象添加到事件循环中执行，随后打印输出 task 对象，发现它的状态变成了 finished，同时还可以看到其 result 变成了 1，也就是定义的 execute 方法的返回结果。</p></blockquote>`,23)]))}const E=i(t,[["render",p]]);export{d as __pageData,E as default};
