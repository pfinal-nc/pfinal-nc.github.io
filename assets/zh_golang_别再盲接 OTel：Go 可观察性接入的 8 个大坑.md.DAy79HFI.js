import{_ as i,c as a,o as e,a6 as t}from"./chunks/framework.dsRYTprt.js";const c=JSON.parse('{"title":"别再盲接 OTel Go 可观察性接入的 8 个大坑","description":"这是一份面向 Go 团队的 OTel 接入避坑指南，覆盖全局 Provider 覆盖、采样与批处理配置、TraceContext 统一、指标高基数控制、Exporter 超时与降级、以及版本升级兼容等关键问题，并给出可落地的默认配置与演练清单。","frontmatter":{"title":"别再盲接 OTel Go 可观察性接入的 8 个大坑","date":"2024-10-23T09:08:02.000Z","tags":["golang","OpenTelemetry"],"description":"这是一份面向 Go 团队的 OTel 接入避坑指南，覆盖全局 Provider 覆盖、采样与批处理配置、TraceContext 统一、指标高基数控制、Exporter 超时与降级、以及版本升级兼容等关键问题，并给出可落地的默认配置与演练清单。","author":"PFinal南丞","keywords":"OTel, OpenTelemetry, Go 可观察性, Go 监控, Jaeger, Prometheus, 采样策略, TraceContext, Exporter, BatchSpanProcessor, 降级策略","head":[["meta",{"name":"keywords","content":"OTel, OpenTelemetry, Go 可观察性, Go 监控, Jaeger, Prometheus, 采样策略, TraceContext, Exporter, BatchSpanProcessor, 降级策略"}]]},"headers":[],"relativePath":"zh/golang/别再盲接 OTel：Go 可观察性接入的 8 个大坑.md","filePath":"zh/golang/别再盲接 OTel：Go 可观察性接入的 8 个大坑.md","lastUpdated":1761215482000}'),l={name:"zh/golang/别再盲接 OTel：Go 可观察性接入的 8 个大坑.md"};function n(r,s,h,p,k,o){return e(),a("div",{"data-pagefind-body":!0},s[0]||(s[0]=[t(`<h1 id="别再盲接-otel-go-可观察性接入的-8-个大坑" tabindex="-1">别再盲接 OTel：Go 可观察性接入的 8 个大坑 <a class="header-anchor" href="#别再盲接-otel-go-可观察性接入的-8-个大坑" aria-label="Permalink to &quot;别再盲接 OTel：Go 可观察性接入的 8 个大坑&quot;">​</a></h1><p>—— 一次凌晨 2 点的告警复盘</p><p>凌晨 2 点，PagerDuty 又响了。 新来的同事刚在服务里“优雅”地接了 OpenTelemetry，说可以全链路观测、一眼洞察系统健康。 结果服务直接炸了，CPU 飙高，日志风暴，Jaeger 面板全绿。所有人看着屏幕上那根笔直的“健康曲线”，没人敢重启。</p><p>这大概是许多 Go 团队第一次“盲接 OTel”的真实写照。 可观察性本来该是你抓 bug 的显微镜，却常常成了新的 bug 来源。</p><h2 id="坑一-全局注册器是隐形炸弹" tabindex="-1">坑一：全局注册器是隐形炸弹 <a class="header-anchor" href="#坑一-全局注册器是隐形炸弹" aria-label="Permalink to &quot;坑一：全局注册器是隐形炸弹&quot;">​</a></h2><p>OTel 的 SDK 喜欢搞“全局变量”，一旦你在多模块服务中初始化了多个 <code>TracerProvider</code> 或 <code>MeterProvider</code>，全局状态就会被覆盖。 结果？有的请求 trace 不全、有的 metrics 丢失、还有的 span 在 Jaeger 中变成“幽灵节点”。</p><p><strong>正确姿势</strong>： 为每个模块显式注入 <code>TracerProvider</code>，不要依赖 <code>otel.GetTracerProvider()</code>。Go 的依赖注入虽然原始，但足够避免这种灾难。</p><h2 id="坑二-exporter-不等于可见性" tabindex="-1">坑二：Exporter 不等于可见性 <a class="header-anchor" href="#坑二-exporter-不等于可见性" aria-label="Permalink to &quot;坑二：Exporter 不等于可见性&quot;">​</a></h2><p>不少团队把 Exporter 当“出口即洞察”。 但 Prometheus Exporter + Jaeger Exporter 只是“发快递”，并不保证你真的“看到”数据。 默认配置下，OTel 的 SDK 会缓存 metric 批次、trace 队列。 量大时，Exporter 堵塞、队列积压、采样丢失，可见性延迟飙升至十几秒。</p><p><strong>建议</strong>：</p><ul><li>在压测环境用 <code>BatchSpanProcessor</code> 配合 <code>WithMaxQueueSize</code> 调优。</li><li>不要盲开 100% 采样。<code>ParentBased(TraceIDRatioBased(0.1))</code> 是更稳妥起点。</li></ul><h2 id="坑三-tracecontext-混乱是最大杀手" tabindex="-1">坑三：TraceContext 混乱是最大杀手 <a class="header-anchor" href="#坑三-tracecontext-混乱是最大杀手" aria-label="Permalink to &quot;坑三：TraceContext 混乱是最大杀手&quot;">​</a></h2><p>很多 Go 团队微服务里一半用 gRPC，一半用 HTTP，再加上消息队列，trace context 就像打了结的麻花。 典型问题是：trace ID 在服务 A 里存在，到服务 B 就重生了。 原因多半是传播器没对齐：一个用了 W3C TraceContext，一个还在用 B3 headers。</p><p><strong>解决方案</strong>： 明确全链路传播协议。团队统一使用 <code>W3C TraceContext</code>，并在每个入口（API Gateway、gRPC Interceptor、Kafka Consumer）显式注入。</p><h2 id="坑四-metrics-无法代表健康" tabindex="-1">坑四：Metrics 无法代表健康 <a class="header-anchor" href="#坑四-metrics-无法代表健康" aria-label="Permalink to &quot;坑四：Metrics 无法代表健康&quot;">​</a></h2><p>OTel Metrics 接入容易，但误解也多。很多人一通 <code>Counter.Add()</code>、<code>Histogram.Record()</code> 后就觉得稳了。 其实问题是：指标一多，Prometheus 抓取周期就成瓶颈。几百个 label 组合，瞬间爆表。 最终结果是：观测数据先把系统拖垮。</p><p><strong>经验</strong>：</p><ul><li>控制 label 数量，不超过 10 个组合维度。</li><li>将高频指标下沉到 Aggregator，不直接暴露。</li><li>核心指标先定义 SLA，再谈可视化。</li></ul><h2 id="坑五-仪表盘-洞察力" tabindex="-1">坑五：仪表盘≠洞察力 <a class="header-anchor" href="#坑五-仪表盘-洞察力" aria-label="Permalink to &quot;坑五：仪表盘≠洞察力&quot;">​</a></h2><p>OTel 能帮你“看到”，但不能帮你“理解”。 盲目堆叠仪表盘，只会制造信息噪音。真正的洞察是从 trace 和 metrics 中“推导出业务关系”。</p><p>比如： 某个 trace latency 升高，但 metrics 还正常。原因可能是某个 goroutine 阻塞，trace 展开后才发现 span 在等待一个外部锁。 这时的关键不是新加监控图表，而是<strong>问自己：我看到了什么，为什么重要？</strong></p><h2 id="坑六-otel-自身性能监控缺失" tabindex="-1">坑六：OTel 自身性能监控缺失 <a class="header-anchor" href="#坑六-otel-自身性能监控缺失" aria-label="Permalink to &quot;坑六：OTel 自身性能监控缺失&quot;">​</a></h2><p>很多团队接入 OTel 后，只关注业务指标，却忘了监控 OTel 本身。 结果就是：OTel 成了新的性能瓶颈，Exporter 队列积压、内存泄漏、CPU 飙升，但你看不到。</p><p><strong>监控要点</strong>：</p><ul><li>监控 <code>BatchSpanProcessor</code> 的队列长度和批处理延迟</li><li>设置 OTel 内部 metrics 的告警阈值</li><li>定期检查 Exporter 的成功率和重试次数</li></ul><h2 id="坑七-exporter-失败时的降级策略" tabindex="-1">坑七：Exporter 失败时的降级策略 <a class="header-anchor" href="#坑七-exporter-失败时的降级策略" aria-label="Permalink to &quot;坑七：Exporter 失败时的降级策略&quot;">​</a></h2><p>生产环境中，Exporter 失败是常态，不是异常。 默认情况下，OTel 会阻塞等待 Exporter 响应，这可能导致整个应用卡死。</p><p><strong>降级策略</strong>：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置合理的超时和重试</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">exporter, err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jaeger.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">New</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jaeger.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WithCollectorEndpoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    jaeger.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WithEndpoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://jaeger:14268/api/traces&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    jaeger.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WithTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">time.Second),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 配置异步处理，避免阻塞</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">processor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> batch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NewBatchSpanProcessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(exporter,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    batch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WithMaxQueueSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    batch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WithExportTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">time.Second),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    batch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WithMaxExportBatchSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h2 id="坑八-版本升级的兼容性陷阱" tabindex="-1">坑八：版本升级的兼容性陷阱 <a class="header-anchor" href="#坑八-版本升级的兼容性陷阱" aria-label="Permalink to &quot;坑八：版本升级的兼容性陷阱&quot;">​</a></h2><p>OTel SDK 更新频繁，API 变化较大。 很多团队升级后，发现原有的 trace 链路断了，metrics 格式变了，dashboard 全红。</p><p><strong>升级策略</strong>：</p><ul><li>先在测试环境验证新版本的行为</li><li>保留旧版本 Exporter 作为备份</li><li>制定分阶段升级计划，避免一次性全量升级</li><li>关注 OTel 官方的迁移指南和 breaking changes</li></ul><h2 id="现场复盘-一次-全绿面板-的事故拆解" tabindex="-1">现场复盘：一次“全绿面板”的事故拆解 <a class="header-anchor" href="#现场复盘-一次-全绿面板-的事故拆解" aria-label="Permalink to &quot;现场复盘：一次“全绿面板”的事故拆解&quot;">​</a></h2><ul><li>时间线：02:00 告警 → 02:05 QPS 下降 → 02:08 Jaeger 全绿 → 02:12 客户支付回调报错集中</li><li>表象：CPU 飙升、日志风暴、Trace 面板健康</li><li>根因：全局 <code>TracerProvider</code> 被覆盖 + Exporter 堵塞导致批量丢失</li><li>处置：临时降采样到 0.05 + 切 <code>SimpleSpanProcessor</code> + 旁路落盘</li><li>教训：全局注册器不可用；Exporter 必须限时+限队列；关键链路要兜底采样</li></ul><h2 id="成本与取舍-观测不是零成本" tabindex="-1">成本与取舍：观测不是零成本 <a class="header-anchor" href="#成本与取舍-观测不是零成本" aria-label="Permalink to &quot;成本与取舍：观测不是零成本&quot;">​</a></h2><ul><li>性能开销（参考压测，服务 A，8C16G）： <ul><li>0%→10% 采样：P99 +3~5%，CPU +5~8%，内存 +150~300MB</li><li>10%→100% 采样：P99 +15~30%，CPU +20~35%，内存 +1~2GB</li></ul></li><li>存储开销（7 天保留）： <ul><li>Trace：~0.5–2 GB/万 QPS/日（取决于 span 丰富度）</li><li>Metrics：与基数×采集周期近似成正比，Label 爆炸最致命</li></ul></li><li>实战基线： <ul><li>采样：<code>ParentBased(TraceIDRatioBased(0.05~0.2))</code> 起步</li><li>热点接口/错误链路：强制 100% 兜底采样</li><li>一条红线：Prom QPS 利用率 &gt; 60% 或基数增长 &gt; 20%/周，必须降维</li></ul></li></ul><h2 id="一页落地清单" tabindex="-1">一页落地清单 <a class="header-anchor" href="#一页落地清单" aria-label="Permalink to &quot;一页落地清单&quot;">​</a></h2><ul class="task-list"><li class="task-list-item"><input type="checkbox" id="cbx_0" disabled="true"><label for="cbx_0"> 统一传播协议：W3C TraceContext（HTTP/gRPC/MQ 全链路）</label></li><li class="task-list-item"><input type="checkbox" id="cbx_1" disabled="true"><label for="cbx_1"> 禁用全局 Provider，显式注入（按模块/服务级）</label></li><li class="task-list-item"><input type="checkbox" id="cbx_2" disabled="true"><label for="cbx_2"> 采样策略：ParentBased + Ratio 0.1，并对关键路径兜底</label></li><li class="task-list-item"><input type="checkbox" id="cbx_3" disabled="true"><label for="cbx_3"> Processor：BatchSpanProcessor（限队列/批量/导出超时）</label></li><li class="task-list-item"><input type="checkbox" id="cbx_4" disabled="true"><label for="cbx_4"> Exporter：超时、重试、断路；旁路落盘（本地/缓冲队列）</label></li><li class="task-list-item"><input type="checkbox" id="cbx_5" disabled="true"><label for="cbx_5"> Metrics：限制 Label 维度≤10；拒绝高基数字符串</label></li><li class="task-list-item"><input type="checkbox" id="cbx_6" disabled="true"><label for="cbx_6"> 监控 OTel 自身：队列长度、批处理延迟、导出成功率</label></li><li class="task-list-item"><input type="checkbox" id="cbx_7" disabled="true"><label for="cbx_7"> 异常演练：拉闸 Collector/Prom，验证降级是否生效</label></li><li class="task-list-item"><input type="checkbox" id="cbx_8" disabled="true"><label for="cbx_8"> 版本策略：灰度升级 + 回滚预案 + 迁移检查表</label></li></ul><h2 id="默认配置模板-go" tabindex="-1">默认配置模板（Go） <a class="header-anchor" href="#默认配置模板-go" aria-label="Permalink to &quot;默认配置模板（Go）&quot;">​</a></h2><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 采样（基线）+ 批处理限流</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sdktrace.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NewTracerProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sdktrace.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WithSampler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sdktrace.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ParentBased</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sdktrace.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TraceIDRatioBased</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sdktrace.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WithBatcher</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        exporter,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sdktrace.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WithMaxQueueSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sdktrace.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WithMaxExportBatchSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">128</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sdktrace.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WithBatchTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">time.Second),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sdktrace.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WithExportTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">time.Second),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 统一传播器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">otel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SetTracerProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tp)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">otel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SetTextMapPropagator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">propagation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TraceContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{})</span></span></code></pre></div><h2 id="讨论-你会选哪一个" tabindex="-1">讨论：你会选哪一个？ <a class="header-anchor" href="#讨论-你会选哪一个" aria-label="Permalink to &quot;讨论：你会选哪一个？&quot;">​</a></h2><ul><li>生产环境是否应该 100% 采样？（可用性 vs 成本）</li><li>W3C TraceContext 一统江湖，是否还要兼容 B3？</li><li>指标高基数 vs 业务维度完整性，谁更重要？</li></ul><p>欢迎留言分享你在 OTel 接入中踩过的坑，我们会挑选典型案例做一次深入复盘。</p><h2 id="小结-otel-不该是另一个-bug" tabindex="-1">小结：OTel 不该是另一个 bug <a class="header-anchor" href="#小结-otel-不该是另一个-bug" aria-label="Permalink to &quot;小结：OTel 不该是另一个 bug&quot;">​</a></h2><p>OpenTelemetry 是个极强的标准，但实现落地绝不是复制粘贴几行初始化代码。 它需要工程文化的支持——对 trace 的重视、对 metrics 的边界理解、对 logs 的整合思考。</p><p>否则，你会得到一个完美的监控面板，和一个仍在失火的生产环境。</p><p><strong>记住一句话</strong>：</p><blockquote><p>观测不是接 OTel，观测是理解系统。</p></blockquote>`,49)]))}const E=i(l,[["render",n]]);export{c as __pageData,E as default};
