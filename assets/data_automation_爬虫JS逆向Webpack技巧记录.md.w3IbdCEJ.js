import{_ as s,c as i,o as t,a6 as e}from"./chunks/framework.BwtyjzPT.js";const d=JSON.parse('{"title":"Python爬虫JS逆向实战指南（Webpack加密破解与数据采集）","description":"","frontmatter":{"title":"Python爬虫JS逆向实战指南（Webpack加密破解与数据采集）","slug":"python-js-reverse-webpack","date":"2023-05-15T00:00:00.000Z","updated":"2023-05-15T00:00:00.000Z","authors":["PFinal南丞"],"categories":["数据与自动化","爬虫技术"],"tags":["python","爬虫","js逆向","webpack","加密破解","数据采集"],"keywords":["python爬虫教程","js逆向技巧","webpack破解方法","数据采集实战","加密网站爬取"],"summary":"详细讲解Python爬虫中的JS逆向技术，重点分析Webpack加密机制和破解方法，提供完整的数据采集解决方案和实战案例。","readingTime":12,"cover":"/images/python-js-reverse.png","status":"published","toc":true,"head":[["link",{"rel":"canonical","href":"https://friday-go.icu/data/automation/爬虫JS逆向Webpack技巧记录"}],["meta",{"name":"keywords","content":"python爬虫教程,js逆向技巧,webpack破解方法,数据采集实战,加密网站爬取, PFinalClub, Golang教程, Go后端开发, Go微服务, PHP, Python, 技术博客"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"TechArticle\\",\\"headline\\":\\"Python爬虫JS逆向实战指南（Webpack加密破解与数据采集）\\",\\"url\\":\\"https://friday-go.icu/data/automation/爬虫JS逆向Webpack技巧记录\\",\\"datePublished\\":\\"2023-05-15T00:00:00.000Z\\",\\"dateModified\\":1765506967000,\\"author\\":{\\"@type\\":\\"Person\\",\\"name\\":\\"PFinal南丞\\",\\"url\\":\\"https://friday-go.icu/about\\"},\\"publisher\\":{\\"@type\\":\\"Organization\\",\\"name\\":\\"PFinalClub\\",\\"logo\\":{\\"@type\\":\\"ImageObject\\",\\"url\\":\\"https://friday-go.icu/logo.png\\"}},\\"description\\":\\"\\",\\"inLanguage\\":\\"zh-CN\\",\\"mainEntityOfPage\\":{\\"@type\\":\\"WebPage\\",\\"@id\\":\\"https://friday-go.icu/data/automation/爬虫JS逆向Webpack技巧记录\\"},\\"keywords\\":[\\"python爬虫教程\\",\\"js逆向技巧\\",\\"webpack破解方法\\",\\"数据采集实战\\",\\"加密网站爬取\\"]}"]]},"headers":[],"relativePath":"data/automation/爬虫JS逆向Webpack技巧记录.md","filePath":"data/automation/爬虫JS逆向Webpack技巧记录.md","lastUpdated":1765506967000}'),n={name:"data/automation/爬虫JS逆向Webpack技巧记录.md"};function p(l,a,h,o,r,k){return t(),i("div",{"data-pagefind-body":!0,"data-pagefind-meta":"date:1684108800000"},a[0]||(a[0]=[e(`<h1 id="爬虫js逆向webpack技巧记录" tabindex="-1">爬虫JS逆向Webpack技巧记录 <a class="header-anchor" href="#爬虫js逆向webpack技巧记录" aria-label="Permalink to &quot;爬虫JS逆向Webpack技巧记录&quot;">​</a></h1><h2 id="概念" tabindex="-1">概念: <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念:&quot;">​</a></h2><p>webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency sgraph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles。所有的资源都是通过JavaScript渲染出来的。</p><h2 id="识别" tabindex="-1">识别: <a class="header-anchor" href="#识别" aria-label="Permalink to &quot;识别:&quot;">​</a></h2><ol><li>如下图所示:</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305151419884.png" alt=""></p><blockquote><p>查看 网页源代码,大部分都是由script标签构成</p></blockquote><ol start="2"><li>如图:</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305160910831.png" alt=""></p><blockquote><p>大部分的webpack 都是可以找到 webpack这个js文件的</p></blockquote><h2 id="结构" tabindex="-1">结构: <a class="header-anchor" href="#结构" aria-label="Permalink to &quot;结构:&quot;">​</a></h2><p>webpack 打包后的js 结构基本上都是 有一个自执行函数用来做加载器 加载模块的,常见的结构如下:</p><h3 id="第一种" tabindex="-1">第一种: <a class="header-anchor" href="#第一种" aria-label="Permalink to &quot;第一种:&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305160951192.png" alt=""></p><p>如图所示:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">funcion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;形参&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;加载器&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;模块&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模块以数组的形式存储,数组中每个元素都是函数</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">..} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这个函数叫做加载器,也可以叫做分发器,所有的模块都是从这个函数加载并执行.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用加载器调用第一个模块</span></span></code></pre></div><h3 id="第二种" tabindex="-1">第二种 <a class="header-anchor" href="#第二种" aria-label="Permalink to &quot;第二种&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305160944584.png" alt=""></p><p>如图所示:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">funcion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;形参&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;加载器&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}({</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;模块&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模块以对象的形式存储,元素都为函数对象</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">..} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这个函数叫做加载器,也可以叫做分发器,所有的模块都是从这个函数加载并执行.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1x2y&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用加载器调用1x2y执行</span></span></code></pre></div><h3 id="第三种" tabindex="-1">第三种 <a class="header-anchor" href="#第三种" aria-label="Permalink to &quot;第三种&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161006212.png" alt=""></p><p><strong>如上图所示,第三种也是最常见的一种.如果模块比较多，就会将模块打包成JS文件, 然后定义一个全局变量 window[&quot;webpackJsonp&quot;] = [ ]，它的作用是存储需要动态导入的模块，然后重写 window[&quot;webpackJsonp&quot;] 数组的 push( ) 方法为 webpackJsonpCallback( ),也就是说 window[&quot;webpackJsonp&quot;].push( ) 其实执行的是 webpackJsonpCallback( ),window[&quot;webpackJsonp&quot;].push( )接收三个参数,第一个参数是模块的ID,第二个参数是 一个数组或者对象,里面定义大量的函数,第三个参数是要调用的函数(可选)。</strong></p><p>每一个JS模块文件开头都是</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window.webpackJsonp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.webpackJsonp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],{}]) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 其中 2 是模块的id  {} 中是要调用的函数对象</span></span></code></pre></div><h2 id="逆向扣取js思路-一" tabindex="-1">逆向扣取JS思路(一) <a class="header-anchor" href="#逆向扣取js思路-一" aria-label="Permalink to &quot;逆向扣取JS思路(一)&quot;">​</a></h2><ol><li>首先找加密参数入口</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161020050.png" alt=""></p><p>如上图所示,加密参数 <em>sign</em></p><ol start="2"><li>找到加载器函数</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161035140.png" alt=""></p><blockquote><p>如上图所示 找到类似这种<strong>n(&#39;xx&#39;)</strong> 调用加载模块的函数然后打断点刷新网页,鼠标移动上去就基本能够找到加载器函数，如下图所示:</p></blockquote><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161038581.png" alt=""></p><ol start="3"><li><p>在加载器函数中的call()方法或者apply()方法打上断点，将加密函数所在的模块和与其相关的模块一起扣取下来。</p></li><li><p>将加密参数升为全局变量导出</p></li></ol><h2 id="逆向扣取js思路-一-1" tabindex="-1">逆向扣取JS思路(一) <a class="header-anchor" href="#逆向扣取js思路-一-1" aria-label="Permalink to &quot;逆向扣取JS思路(一)&quot;">​</a></h2><ol><li>找到加密参数函数入口,确定加密函数所在的模块。</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161044042.png" alt=""></p><ol start="2"><li>找到加密模块 扣下来</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161050194.png" alt=""></p><p>如上图的所示,m函数所在的模块加载了其他模块依次找一下,找到如下图所示的加密模块</p><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161052841.png" alt=""></p><ol start="3"><li>在本地依次往上扣取代码,然后报错 缺啥补啥</li></ol><p>扣下上面的加密模块以后 然后开始补齐其他所缺的函数及其一些参数就可以试试看了</p><blockquote><p>注意: 在加密函数(方法)和加密函数(方法)后打上两个断点，断点在加密函数(方法)断住后，追入到加载器函数,然后在加载器后面下断点(类似 return e[n].call(r.exports, r, r.exports, d) )，跳转到加载器后面的断点，在控制台输入HooK函数(根据不同的加载器函数改变HooK函数代码),取消加载器后面的断点,跳转到加密函数(方法)后的断点,在控制台输入window._wbpk 后得到所有与加密函数有关的模块代码。</p></blockquote><h3 id="其他思路持续更新中" tabindex="-1">其他思路持续更新中... <a class="header-anchor" href="#其他思路持续更新中" aria-label="Permalink to &quot;其他思路持续更新中...&quot;">​</a></h3>`,47)]))}const g=s(n,[["render",p]]);export{d as __pageData,g as default};
