import{_ as s,c as i,o as t,a6 as l}from"./chunks/framework.B5rgnJXo.js";const c=JSON.parse('{"title":"爬虫JS逆向Webpack技巧记录","description":"爬虫JS逆向Webpack技巧记录","frontmatter":{"title":"爬虫JS逆向Webpack技巧记录","date":"2023-05-15T10:14:02.000Z","tags":["爬虫","python","Webpack"],"description":"爬虫JS逆向Webpack技巧记录","author":"PFinal南丞","keywords":"爬虫JS逆向Webpack技巧记录, 爬虫, JS, Webpack,爬虫, 加密, 解密, 算法, 特征, 收集,爬虫, 加密, 解密, 算法, 特征, 收集,Composer, 配置文件, 依赖管理, 包管理, 版本控制,PHP, 进程, 线程, 解析, PHP进程, PHP线程, PHP进程线程, PHP进程线程解析, PHP进程线程解析,PHP, $_SERVER,PHP, 会话, 引发, Bug, PHP_SESSION, $_SESSION, 会话管理,PHP, 错误与异常处理, 异常, 错误, 处理, 异常处理, 错误处理, 程序, 健壮性, 稳定性,PHP, 生成器, 解析, PHP生成器, PHP生成器解析, PHP生成器解析,golang, gopsutil, 系统库, 监控, 系统信息, 进程, 进程监控, 系统信息获取,使用Go实现服务端事件推送SSE, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,用Wails和Vue.js打造跨平台桌面应用程序, Wails, Vue.js, 跨平台桌面应用程序, 抖音, 直播,基于Wails的Mac桌面应用开发, golang, Wails, 桌面应用, 开发,基于Wails的抖音直播工具, golang, Wails, 抖音, 直播, 工具, 桌面应用,golang, 游戏开发, 接口设计, 高性能, 高并发, 游戏服务器, 游戏接口, 游戏框架,Wails, 应用, 开发, 尝试, 桌面应用, Go, Web开发, Tailwindcss, sqlite,Go-Cache, Wails, 内存缓存, 性能优化, 缓存策略, 内存管理, 应用程序性能,golang, 工具, 提升生产力, 开发, golang, Go开发, Go工具, Go扩展包,提速利器：使用Go语言实现静态化API, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,深入Go内存分配, golang, 内存分配,Go Channel, 批量读取, 实际应用,Laravel, 构建, 手工, 框架, 手工构建, PHP,Laravel, Carbon, 类, 使用, Laravel-Carbon-类使用, Laravel-Carbon-类使用解析,Golang, Web应用, 安全指南, 输入验证, 输出编码, 会话管理, 文件上传, 跨站脚本攻击, SQL注入, 密码存储, 身份验证, 授权, 安全配置, 日志记录, 错误处理, 性能优化, 安全审计,golang, TLS, SSL, 网络安全, 传输层安全协议, 安全套接层, 加密, 数据传输, 网络通信,Golang, 协程池, 实现, 方法, 协程, 池, 概念, 应用, 场景, 实现方式, 协程池功能, 性能, 响应速度,golang, 脱敏扩展包：简化敏感信息处理的利器, 工具, golang扩展包, golang脱敏, golang脱敏工具,Golang, 工具, 效率, 提升, 小工具, 代码质量, 开发, 编程, 工具, 自动格式化, 自动导入, 代码补全,undefined,AutoCorrent专有名词大小写扩展包, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,Create Go App CLI, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,Go语言开发终端小工具后续, Go, 工具, 终端, 小工具, 开发, 编程, 命令, 工具开发, 代码实现, 运行命令,GO开发IP过滤小脚本, go, 工具, go开发ip过滤, go ip过滤脚本, go ip过滤,Go 开发终端小工具, golang, 工具, 开发, 编程, 终端, 天气查询, 手机归属地查询, cobra库, 命令行小工具,Go语言的高性能User-Agent解析库, golang, 工具, User-Agent解析, 性能测试, 解析库,golang, 地址生成, 扩展包, 地理位置, 中国地址, 地址生成工具, 地址数据, 地址库,Gomail邮件发送包, golang, 工具, 邮件发送, 邮件接收, 邮件发送包, 邮件发送工具,Go语言安全库使用指南, Go语言, 安全库, 使用指南, crypto, encoding, hash, math, rand, strconv, time,Go, URL检测, 工具, 编程, 终端命令, 开发, 检测, 小工具, 终端命令小工具, Go终端命令小工具,Go语言实现守护进程, 守护进程, 技术详解, Go语言, 进程管理, 关键技术点,Go, 并发, 模式, 编程, 并发编程, Go语言, 并发模式, 并发实战, 并发指南,go:embed 在 Go 开发中的应用与最佳实践, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,pfinalclub, git, gitsite, javascript, node, jquery, python, php, laravel, sql, database, linux, operating system, os, cpu, verilog, risc-v, bitcoin, ethereum, ai, 教程, 软件, 编程, 开发, 运维, 云计算, 网络, 互联网, 比特币, 以太坊, 操作系统, 智能合约, 数字货币, 爬虫, 逆向"},"headers":[],"relativePath":"python/爬虫JS逆向Webpack技巧记录.md","filePath":"python/爬虫JS逆向Webpack技巧记录.md","lastUpdated":1742363014000}'),n={name:"python/爬虫JS逆向Webpack技巧记录.md"};function e(p,a,h,o,r,k){return t(),i("div",{"data-pagefind-body":!0},a[0]||(a[0]=[l(`<h1 id="爬虫js逆向webpack技巧记录" tabindex="-1">爬虫JS逆向Webpack技巧记录 <a class="header-anchor" href="#爬虫js逆向webpack技巧记录" aria-label="Permalink to &quot;爬虫JS逆向Webpack技巧记录&quot;">​</a></h1><h2 id="概念" tabindex="-1">概念: <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念:&quot;">​</a></h2><p>webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency sgraph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles。所有的资源都是通过JavaScript渲染出来的。</p><h2 id="识别" tabindex="-1">识别: <a class="header-anchor" href="#识别" aria-label="Permalink to &quot;识别:&quot;">​</a></h2><ol><li>如下图所示:</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305151419884.png" alt=""></p><blockquote><p>查看 网页源代码,大部分都是由script标签构成</p></blockquote><ol start="2"><li>如图:</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305160910831.png" alt=""></p><blockquote><p>大部分的webpack 都是可以找到 webpack这个js文件的</p></blockquote><h2 id="结构" tabindex="-1">结构: <a class="header-anchor" href="#结构" aria-label="Permalink to &quot;结构:&quot;">​</a></h2><p>webpack 打包后的js 结构基本上都是 有一个自执行函数用来做加载器 加载模块的,常见的结构如下:</p><h3 id="第一种" tabindex="-1">第一种: <a class="header-anchor" href="#第一种" aria-label="Permalink to &quot;第一种:&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305160951192.png" alt=""></p><p>如图所示:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">funcion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;形参&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;加载器&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;模块&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模块以数组的形式存储,数组中每个元素都是函数</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">..} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这个函数叫做加载器,也可以叫做分发器,所有的模块都是从这个函数加载并执行.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用加载器调用第一个模块</span></span></code></pre></div><h3 id="第二种" tabindex="-1">第二种 <a class="header-anchor" href="#第二种" aria-label="Permalink to &quot;第二种&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305160944584.png" alt=""></p><p>如图所示:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">funcion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;形参&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;加载器&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}({</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;模块&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模块以对象的形式存储,元素都为函数对象</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">..} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这个函数叫做加载器,也可以叫做分发器,所有的模块都是从这个函数加载并执行.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1x2y&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用加载器调用1x2y执行</span></span></code></pre></div><h3 id="第三种" tabindex="-1">第三种 <a class="header-anchor" href="#第三种" aria-label="Permalink to &quot;第三种&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161006212.png" alt=""></p><p><strong>如上图所示,第三种也是最常见的一种.如果模块比较多，就会将模块打包成JS文件, 然后定义一个全局变量 window[&quot;webpackJsonp&quot;] = [ ]，它的作用是存储需要动态导入的模块，然后重写 window[&quot;webpackJsonp&quot;] 数组的 push( ) 方法为 webpackJsonpCallback( ),也就是说 window[&quot;webpackJsonp&quot;].push( ) 其实执行的是 webpackJsonpCallback( ),window[&quot;webpackJsonp&quot;].push( )接收三个参数,第一个参数是模块的ID,第二个参数是 一个数组或者对象,里面定义大量的函数,第三个参数是要调用的函数(可选)。</strong></p><p>每一个JS模块文件开头都是</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window.webpackJsonp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.webpackJsonp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],{}]) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 其中 2 是模块的id  {} 中是要调用的函数对象</span></span></code></pre></div><h2 id="逆向扣取js思路-一" tabindex="-1">逆向扣取JS思路(一) <a class="header-anchor" href="#逆向扣取js思路-一" aria-label="Permalink to &quot;逆向扣取JS思路(一)&quot;">​</a></h2><ol><li>首先找加密参数入口</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161020050.png" alt=""></p><p>如上图所示,加密参数 <em>sign</em></p><ol start="2"><li>找到加载器函数</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161035140.png" alt=""></p><blockquote><p>如上图所示 找到类似这种<strong>n(&#39;xx&#39;)</strong> 调用加载模块的函数然后打断点刷新网页,鼠标移动上去就基本能够找到加载器函数，如下图所示:</p></blockquote><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161038581.png" alt=""></p><ol start="3"><li><p>在加载器函数中的call()方法或者apply()方法打上断点，将加密函数所在的模块和与其相关的模块一起扣取下来。</p></li><li><p>将加密参数升为全局变量导出</p></li></ol><h2 id="逆向扣取js思路-一-1" tabindex="-1">逆向扣取JS思路(一) <a class="header-anchor" href="#逆向扣取js思路-一-1" aria-label="Permalink to &quot;逆向扣取JS思路(一)&quot;">​</a></h2><ol><li>找到加密参数函数入口,确定加密函数所在的模块。</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161044042.png" alt=""></p><ol start="2"><li>找到加密模块 扣下来</li></ol><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161050194.png" alt=""></p><p>如上图的所示,m函数所在的模块加载了其他模块依次找一下,找到如下图所示的加密模块</p><p><img src="https://raw.githubusercontent.com/pfinal-nc/iGallery/master/blog/202305161052841.png" alt=""></p><ol start="3"><li>在本地依次往上扣取代码,然后报错 缺啥补啥</li></ol><p>扣下上面的加密模块以后 然后开始补齐其他所缺的函数及其一些参数就可以试试看了</p><blockquote><p>注意: 在加密函数(方法)和加密函数(方法)后打上两个断点，断点在加密函数(方法)断住后，追入到加载器函数,然后在加载器后面下断点(类似 return e[n].call(r.exports, r, r.exports, d) )，跳转到加载器后面的断点，在控制台输入HooK函数(根据不同的加载器函数改变HooK函数代码),取消加载器后面的断点,跳转到加密函数(方法)后的断点,在控制台输入window._wbpk 后得到所有与加密函数有关的模块代码。</p></blockquote><h3 id="其他思路持续更新中" tabindex="-1">其他思路持续更新中... <a class="header-anchor" href="#其他思路持续更新中" aria-label="Permalink to &quot;其他思路持续更新中...&quot;">​</a></h3>`,47)]))}const d=s(n,[["render",e]]);export{c as __pageData,d as default};
