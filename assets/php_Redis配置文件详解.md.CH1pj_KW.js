import{_ as n,c as a,o as p,a6 as e}from"./chunks/framework.B5rgnJXo.js";const m=JSON.parse('{"title":"Redis配置文件详解","description":"学习Redis配置文件","frontmatter":{"title":"Redis配置文件详解","date":"2020-06-09T11:31:32.000Z","tags":["Redis"],"description":"学习Redis配置文件","keywords":"Redis配置文件详解, 数据库, redis,TCP/IP,HTTP,Python, 库, 函数, 常用, Faker, 生成, 数据, 测试, 模拟,Python, 协程, 并发, 编程, asyncio, 异步IO, Future, Task,Python, 网站, 搜集, 资源, 开发, 编程, 工具, 镜像站, 爬虫,Python版本管理神器之pyenv, python, 工具, python版本管理, pyenv使用教程, python环境配置,爬虫JS逆向Webpack技巧记录, 爬虫, JS, Webpack,爬虫, 加密, 解密, 算法, 特征, 收集,爬虫, 加密, 解密, 算法, 特征, 收集,Composer, 配置文件, 依赖管理, 包管理, 版本控制,PHP, 进程, 线程, 解析, PHP进程, PHP线程, PHP进程线程, PHP进程线程解析, PHP进程线程解析,PHP, $_SERVER,PHP, 会话, 引发, Bug, PHP_SESSION, $_SESSION, 会话管理,PHP, 错误与异常处理, 异常, 错误, 处理, 异常处理, 错误处理, 程序, 健壮性, 稳定性,PHP, 生成器, 解析, PHP生成器, PHP生成器解析, PHP生成器解析,golang, gopsutil, 系统库, 监控, 系统信息, 进程, 进程监控, 系统信息获取,使用Go实现服务端事件推送SSE, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,用Wails和Vue.js打造跨平台桌面应用程序, Wails, Vue.js, 跨平台桌面应用程序, 抖音, 直播,基于Wails的Mac桌面应用开发, golang, Wails, 桌面应用, 开发,基于Wails的抖音直播工具, golang, Wails, 抖音, 直播, 工具, 桌面应用,golang, 游戏开发, 接口设计, 高性能, 高并发, 游戏服务器, 游戏接口, 游戏框架,Wails, 应用, 开发, 尝试, 桌面应用, Go, Web开发, Tailwindcss, sqlite,Go-Cache, Wails, 内存缓存, 性能优化, 缓存策略, 内存管理, 应用程序性能,golang, 工具, 提升生产力, 开发, golang, Go开发, Go工具, Go扩展包,提速利器：使用Go语言实现静态化API, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,深入Go内存分配, golang, 内存分配,Go Channel, 批量读取, 实际应用,Laravel, 构建, 手工, 框架, 手工构建, PHP,Laravel, Carbon, 类, 使用, Laravel-Carbon-类使用, Laravel-Carbon-类使用解析,Golang, Web应用, 安全指南, 输入验证, 输出编码, 会话管理, 文件上传, 跨站脚本攻击, SQL注入, 密码存储, 身份验证, 授权, 安全配置, 日志记录, 错误处理, 性能优化, 安全审计,golang, TLS, SSL, 网络安全, 传输层安全协议, 安全套接层, 加密, 数据传输, 网络通信,Golang, 协程池, 实现, 方法, 协程, 池, 概念, 应用, 场景, 实现方式, 协程池功能, 性能, 响应速度,golang, 脱敏扩展包：简化敏感信息处理的利器, 工具, golang扩展包, golang脱敏, golang脱敏工具,Golang, 工具, 效率, 提升, 小工具, 代码质量, 开发, 编程, 工具, 自动格式化, 自动导入, 代码补全,undefined,AutoCorrent专有名词大小写扩展包, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,Create Go App CLI, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,Go语言开发终端小工具后续, Go, 工具, 终端, 小工具, 开发, 编程, 命令, 工具开发, 代码实现, 运行命令,GO开发IP过滤小脚本, go, 工具, go开发ip过滤, go ip过滤脚本, go ip过滤,Go 开发终端小工具, golang, 工具, 开发, 编程, 终端, 天气查询, 手机归属地查询, cobra库, 命令行小工具,Go语言的高性能User-Agent解析库, golang, 工具, User-Agent解析, 性能测试, 解析库,golang, 地址生成, 扩展包, 地理位置, 中国地址, 地址生成工具, 地址数据, 地址库,Gomail邮件发送包, golang, 工具, 邮件发送, 邮件接收, 邮件发送包, 邮件发送工具,Go语言安全库使用指南, Go语言, 安全库, 使用指南, crypto, encoding, hash, math, rand, strconv, time,Go, URL检测, 工具, 编程, 终端命令, 开发, 检测, 小工具, 终端命令小工具, Go终端命令小工具,Go语言实现守护进程, 守护进程, 技术详解, Go语言, 进程管理, 关键技术点,Go, 并发, 模式, 编程, 并发编程, Go语言, 并发模式, 并发实战, 并发指南,go:embed 在 Go 开发中的应用与最佳实践, golang, 项目创建, 快速创建, 工具, 项目, 快速, 工具,pfinalclub, git, gitsite, javascript, node, jquery, python, php, laravel, sql, database, linux, operating system, os, cpu, verilog, risc-v, bitcoin, ethereum, ai, 教程, 软件, 编程, 开发, 运维, 云计算, 网络, 互联网, 比特币, 以太坊, 操作系统, 智能合约, 数字货币, 爬虫, 逆向","author":"PFinal南丞"},"headers":[],"relativePath":"php/Redis配置文件详解.md","filePath":"php/Redis配置文件详解.md","lastUpdated":1741944848000}'),l={name:"php/Redis配置文件详解.md"};function i(t,s,o,c,r,d){return p(),a("div",{"data-pagefind-body":!0},s[0]||(s[0]=[e(`<h1 id="redis配置文件详解" tabindex="-1">Redis配置文件详解 <a class="header-anchor" href="#redis配置文件详解" aria-label="Permalink to &quot;Redis配置文件详解&quot;">​</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># Redis配置文件样例</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Note on units: when memory size is needed, it is possible to specifiy</span></span>
<span class="line"><span># it in the usual form of 1k 5GB 4M and so forth:</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># 1k =&gt; 1000 bytes</span></span>
<span class="line"><span># 1kb =&gt; 1024 bytes</span></span>
<span class="line"><span># 1m =&gt; 1000000 bytes</span></span>
<span class="line"><span># 1mb =&gt; 1024*1024 bytes</span></span>
<span class="line"><span># 1g =&gt; 1000000000 bytes</span></span>
<span class="line"><span># 1gb =&gt; 1024*1024*1024 bytes</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span></span>
<span class="line"><span># 启用守护进程后，Redis会把pid写到一个pidfile中，在/var/run/redis.pid</span></span>
<span class="line"><span>daemonize no</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span></span>
<span class="line"><span>pidfile /var/run/redis.pid</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定Redis监听端口，默认端口为6379</span></span>
<span class="line"><span># 如果指定0端口，表示Redis不监听TCP连接</span></span>
<span class="line"><span>port 6379</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 绑定的主机地址</span></span>
<span class="line"><span># 你可以绑定单一接口，如果没有绑定，所有接口都会监听到来的连接</span></span>
<span class="line"><span># bind 127.0.0.1</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Specify the path for the unix socket that will be used to listen for</span></span>
<span class="line"><span># incoming connections. There is no default, so Redis will not listen</span></span>
<span class="line"><span># on a unix socket when not specified.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># unixsocket /tmp/redis.sock</span></span>
<span class="line"><span># unixsocketperm 755</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span></span>
<span class="line"><span>timeout 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span></span>
<span class="line"><span># debug (很多信息, 对开发／测试比较有用)</span></span>
<span class="line"><span># verbose (many rarely useful info, but not a mess like the debug level)</span></span>
<span class="line"><span># notice (moderately verbose, what you want in production probably)</span></span>
<span class="line"><span># warning (only very important / critical messages are logged)</span></span>
<span class="line"><span>loglevel verbose</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 日志记录方式，默认为标准输出，如果配置为redis为守护进程方式运行，而这里又配置为标准输出，则日志将会发送给/dev/null</span></span>
<span class="line"><span>logfile stdout</span></span>
<span class="line"><span></span></span>
<span class="line"><span># To enable logging to the system logger, just set &#39;syslog-enabled&#39; to yes,</span></span>
<span class="line"><span># and optionally update the other syslog parameters to suit your needs.</span></span>
<span class="line"><span># syslog-enabled no</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Specify the syslog identity.</span></span>
<span class="line"><span># syslog-ident redis</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Specify the syslog facility.  Must be USER or between LOCAL0-LOCAL7.</span></span>
<span class="line"><span># syslog-facility local0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 设置数据库的数量，默认数据库为0，可以使用select &lt;dbid&gt;命令在连接上指定数据库id</span></span>
<span class="line"><span># dbid是从0到‘databases’-1的数目</span></span>
<span class="line"><span>databases 16</span></span>
<span class="line"><span></span></span>
<span class="line"><span>################################ SNAPSHOTTING  #################################</span></span>
<span class="line"><span># 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span></span>
<span class="line"><span># Save the DB on disk:</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span>#   save &lt;seconds&gt; &lt;changes&gt;</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span>#   Will save the DB if both the given number of seconds and the given</span></span>
<span class="line"><span>#   number of write operations against the DB occurred.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span>#   满足以下条件将会同步数据:</span></span>
<span class="line"><span>#   900秒（15分钟）内有1个更改</span></span>
<span class="line"><span>#   300秒（5分钟）内有10个更改</span></span>
<span class="line"><span>#   60秒内有10000个更改</span></span>
<span class="line"><span>#   Note: 可以把所有“save”行注释掉，这样就取消同步操作了</span></span>
<span class="line"><span></span></span>
<span class="line"><span>save 900 1</span></span>
<span class="line"><span>save 300 10</span></span>
<span class="line"><span>save 60 10000</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span></span>
<span class="line"><span>rdbcompression yes</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定本地数据库文件名，默认值为dump.rdb</span></span>
<span class="line"><span>dbfilename dump.rdb</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 工作目录.</span></span>
<span class="line"><span># 指定本地数据库存放目录，文件名由上一个dbfilename配置项指定</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># Also the Append Only File will be created inside this directory.</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># 注意，这里只能指定一个目录，不能指定文件名</span></span>
<span class="line"><span>dir ./</span></span>
<span class="line"><span></span></span>
<span class="line"><span>################################# REPLICATION #################################</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 主从复制。使用slaveof从 Redis服务器复制一个Redis实例。注意，该配置仅限于当前slave有效</span></span>
<span class="line"><span># so for example it is possible to configure the slave to save the DB with a</span></span>
<span class="line"><span># different interval, or to listen to another port, and so on.</span></span>
<span class="line"><span># 设置当本机为slav服务时，设置master服务的ip地址及端口，在Redis启动时，它会自动从master进行数据同步</span></span>
<span class="line"><span># slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 当master服务设置了密码保护时，slav服务连接master的密码</span></span>
<span class="line"><span># 下文的“requirepass”配置项可以指定密码</span></span>
<span class="line"><span># masterauth &lt;master-password&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># When a slave lost the connection with the master, or when the replication</span></span>
<span class="line"><span># is still in progress, the slave can act in two different ways:</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># 1) if slave-serve-stale-data is set to &#39;yes&#39; (the default) the slave will</span></span>
<span class="line"><span>#    still reply to client requests, possibly with out of data data, or the</span></span>
<span class="line"><span>#    data set may just be empty if this is the first synchronization.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># 2) if slave-serve-stale data is set to &#39;no&#39; the slave will reply with</span></span>
<span class="line"><span>#    an error &quot;SYNC with master in progress&quot; to all the kind of commands</span></span>
<span class="line"><span>#    but to INFO and SLAVEOF.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span>slave-serve-stale-data yes</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Slaves send PINGs to server in a predefined interval. It&#39;s possible to change</span></span>
<span class="line"><span># this interval with the repl_ping_slave_period option. The default value is 10</span></span>
<span class="line"><span># seconds.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># repl-ping-slave-period 10</span></span>
<span class="line"><span></span></span>
<span class="line"><span># The following option sets a timeout for both Bulk transfer I/O timeout and</span></span>
<span class="line"><span># master data or ping response timeout. The default value is 60 seconds.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># It is important to make sure that this value is greater than the value</span></span>
<span class="line"><span># specified for repl-ping-slave-period otherwise a timeout will be detected</span></span>
<span class="line"><span># every time there is low traffic between the master and the slave.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># repl-timeout 60</span></span>
<span class="line"><span></span></span>
<span class="line"><span>################################## SECURITY ###################################</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Warning: since Redis is pretty fast an outside user can try up to</span></span>
<span class="line"><span># 150k passwords per second against a good box. This means that you should</span></span>
<span class="line"><span># use a very strong password otherwise it will be very easy to break.</span></span>
<span class="line"><span># 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过auth &lt;password&gt;命令提供密码，默认关闭</span></span>
<span class="line"><span># requirepass foobared</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Command renaming.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># It is possilbe to change the name of dangerous commands in a shared</span></span>
<span class="line"><span># environment. For instance the CONFIG command may be renamed into something</span></span>
<span class="line"><span># of hard to guess so that it will be still available for internal-use</span></span>
<span class="line"><span># tools but not available for general clients.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># Example:</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># It is also possilbe to completely kill a command renaming it into</span></span>
<span class="line"><span># an empty string:</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># rename-command CONFIG &quot;&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>################################### LIMITS ####################################</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，</span></span>
<span class="line"><span># 如果设置maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max Number of clients reached错误信息</span></span>
<span class="line"><span># maxclients 128</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Don&#39;t use more memory than the specified amount of bytes.</span></span>
<span class="line"><span># When the memory limit is reached Redis will try to remove keys with an</span></span>
<span class="line"><span># EXPIRE set. It will try to start freeing keys that are going to expire</span></span>
<span class="line"><span># in little time and preserve keys with a longer time to live.</span></span>
<span class="line"><span># Redis will also try to remove objects from free lists if possible.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># If all this fails, Redis will start to reply with errors to commands</span></span>
<span class="line"><span># that will use more memory, like SET, LPUSH, and so on, and will continue</span></span>
<span class="line"><span># to reply to most read-only commands like GET.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># WARNING: maxmemory can be a good idea mainly if you want to use Redis as a</span></span>
<span class="line"><span># &#39;state&#39; server or cache, not as a real DB. When Redis is used as a real</span></span>
<span class="line"><span># database the memory usage will grow over the weeks, it will be obvious if</span></span>
<span class="line"><span># it is going to use too much memory in the long run, and you&#39;ll have the time</span></span>
<span class="line"><span># to upgrade. With maxmemory after the limit is reached you&#39;ll start to get</span></span>
<span class="line"><span># errors for write operations, and this may even lead to DB inconsistency.</span></span>
<span class="line"><span># 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，</span></span>
<span class="line"><span># 当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。</span></span>
<span class="line"><span># Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span></span>
<span class="line"><span># maxmemory &lt;bytes&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span></span>
<span class="line"><span># is reached? You can select among five behavior:</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># volatile-lru -&gt; remove the key with an expire set using an LRU algorithm</span></span>
<span class="line"><span># allkeys-lru -&gt; remove any key accordingly to the LRU algorithm</span></span>
<span class="line"><span># volatile-random -&gt; remove a random key with an expire set</span></span>
<span class="line"><span># allkeys-&gt;random -&gt; remove a random key, any key</span></span>
<span class="line"><span># volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)</span></span>
<span class="line"><span># noeviction -&gt; don&#39;t expire at all, just return an error on write operations</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># Note: with all the kind of policies, Redis will return an error on write</span></span>
<span class="line"><span>#       operations, when there are not suitable keys for eviction.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span>#       At the date of writing this commands are: set setnx setex append</span></span>
<span class="line"><span>#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span></span>
<span class="line"><span>#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span></span>
<span class="line"><span>#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span></span>
<span class="line"><span>#       getset mset msetnx exec sort</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># The default is:</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># maxmemory-policy volatile-lru</span></span>
<span class="line"><span></span></span>
<span class="line"><span># LRU and minimal TTL algorithms are not precise algorithms but approximated</span></span>
<span class="line"><span># algorithms (in order to save memory), so you can select as well the sample</span></span>
<span class="line"><span># size to check. For instance for default Redis will check three keys and</span></span>
<span class="line"><span># pick the one that was used less recently, you can change the sample size</span></span>
<span class="line"><span># using the following configuration directive.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># maxmemory-samples 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>############################## APPEND ONLY MODE ###############################</span></span>
<span class="line"><span></span></span>
<span class="line"><span># </span></span>
<span class="line"><span># Note that you can have both the async dumps and the append only file if you</span></span>
<span class="line"><span># like (you have to comment the &quot;save&quot; statements above to disable the dumps).</span></span>
<span class="line"><span># Still if append only mode is enabled Redis will load the data from the</span></span>
<span class="line"><span># log file at startup ignoring the dump.rdb file.</span></span>
<span class="line"><span># 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。</span></span>
<span class="line"><span># 因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span></span>
<span class="line"><span># IMPORTANT: Check the BGREWRITEAOF to check how to rewrite the append</span></span>
<span class="line"><span># log file in background when it gets too big.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>appendonly no</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定更新日志文件名，默认为appendonly.aof</span></span>
<span class="line"><span># appendfilename appendonly.aof</span></span>
<span class="line"><span></span></span>
<span class="line"><span># The fsync() call tells the Operating System to actually write data on disk</span></span>
<span class="line"><span># instead to wait for more data in the output buffer. Some OS will really flush </span></span>
<span class="line"><span># data on disk, some other OS will just try to do it ASAP.</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定更新日志条件，共有3个可选值：</span></span>
<span class="line"><span># no:表示等操作系统进行数据缓存同步到磁盘（快）</span></span>
<span class="line"><span># always:表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）</span></span>
<span class="line"><span># everysec:表示每秒同步一次（折衷，默认值）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>appendfsync everysec</span></span>
<span class="line"><span># appendfsync no</span></span>
<span class="line"><span></span></span>
<span class="line"><span># When the AOF fsync policy is set to always or everysec, and a background</span></span>
<span class="line"><span># saving process (a background save or AOF log background rewriting) is</span></span>
<span class="line"><span># performing a lot of I/O against the disk, in some Linux configurations</span></span>
<span class="line"><span># Redis may block too long on the fsync() call. Note that there is no fix for</span></span>
<span class="line"><span># this currently, as even performing fsync in a different thread will block</span></span>
<span class="line"><span># our synchronous write(2) call.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># In order to mitigate this problem it&#39;s possible to use the following option</span></span>
<span class="line"><span># that will prevent fsync() from being called in the main process while a</span></span>
<span class="line"><span># BGSAVE or BGREWRITEAOF is in progress.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># This means that while another child is saving the durability of Redis is</span></span>
<span class="line"><span># the same as &quot;appendfsync none&quot;, that in pratical terms means that it is</span></span>
<span class="line"><span># possible to lost up to 30 seconds of log in the worst scenario (with the</span></span>
<span class="line"><span># default Linux settings).</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span></span>
<span class="line"><span># &quot;no&quot; that is the safest pick from the point of view of durability.</span></span>
<span class="line"><span>no-appendfsync-on-rewrite no</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Automatic rewrite of the append only file.</span></span>
<span class="line"><span># Redis is able to automatically rewrite the log file implicitly calling</span></span>
<span class="line"><span># BGREWRITEAOF when the AOF log size will growth by the specified percentage.</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># This is how it works: Redis remembers the size of the AOF file after the</span></span>
<span class="line"><span># latest rewrite (or if no rewrite happened since the restart, the size of</span></span>
<span class="line"><span># the AOF at startup is used).</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># This base size is compared to the current size. If the current size is</span></span>
<span class="line"><span># bigger than the specified percentage, the rewrite is triggered. Also</span></span>
<span class="line"><span># you need to specify a minimal size for the AOF file to be rewritten, this</span></span>
<span class="line"><span># is useful to avoid rewriting the AOF file even if the percentage increase</span></span>
<span class="line"><span># is reached but it is still pretty small.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># Specify a precentage of zero in order to disable the automatic AOF</span></span>
<span class="line"><span># rewrite feature.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>auto-aof-rewrite-percentage 100</span></span>
<span class="line"><span>auto-aof-rewrite-min-size 64mb</span></span>
<span class="line"><span></span></span>
<span class="line"><span>################################## SLOW LOG ###################################</span></span>
<span class="line"><span></span></span>
<span class="line"><span># The Redis Slow Log is a system to log queries that exceeded a specified</span></span>
<span class="line"><span># execution time. The execution time does not include the I/O operations</span></span>
<span class="line"><span># like talking with the client, sending the reply and so forth,</span></span>
<span class="line"><span># but just the time needed to actually execute the command (this is the only</span></span>
<span class="line"><span># stage of command execution where the thread is blocked and can not serve</span></span>
<span class="line"><span># other requests in the meantime).</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># You can configure the slow log with two parameters: one tells Redis</span></span>
<span class="line"><span># what is the execution time, in microseconds, to exceed in order for the</span></span>
<span class="line"><span># command to get logged, and the other parameter is the length of the</span></span>
<span class="line"><span># slow log. When a new command is logged the oldest one is removed from the</span></span>
<span class="line"><span># queue of logged commands.</span></span>
<span class="line"><span></span></span>
<span class="line"><span># The following time is expressed in microseconds, so 1000000 is equivalent</span></span>
<span class="line"><span># to one second. Note that a negative number disables the slow log, while</span></span>
<span class="line"><span># a value of zero forces the logging of every command.</span></span>
<span class="line"><span>slowlog-log-slower-than 10000</span></span>
<span class="line"><span></span></span>
<span class="line"><span># There is no limit to this length. Just be aware that it will consume memory.</span></span>
<span class="line"><span># You can reclaim memory used by the slow log with SLOWLOG RESET.</span></span>
<span class="line"><span>slowlog-max-len 1024</span></span>
<span class="line"><span></span></span>
<span class="line"><span>################################ VIRTUAL MEMORY ###############################</span></span>
<span class="line"><span></span></span>
<span class="line"><span>### WARNING! Virtual Memory is deprecated in Redis 2.4</span></span>
<span class="line"><span>### The use of Virtual Memory is strongly discouraged.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>### WARNING! Virtual Memory is deprecated in Redis 2.4</span></span>
<span class="line"><span>### The use of Virtual Memory is strongly discouraged.</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Virtual Memory allows Redis to work with datasets bigger than the actual</span></span>
<span class="line"><span># amount of RAM needed to hold the whole dataset in memory.</span></span>
<span class="line"><span># In order to do so very used keys are taken in memory while the other keys</span></span>
<span class="line"><span># are swapped into a swap file, similarly to what operating systems do</span></span>
<span class="line"><span># with memory pages.</span></span>
<span class="line"><span># 指定是否启用虚拟内存机制，默认值为no，</span></span>
<span class="line"><span># VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中</span></span>
<span class="line"><span># 把vm-enabled设置为yes，根据需要设置好接下来的三个VM参数，就可以启动VM了</span></span>
<span class="line"><span>vm-enabled no</span></span>
<span class="line"><span># vm-enabled yes</span></span>
<span class="line"><span></span></span>
<span class="line"><span># This is the path of the Redis swap file. As you can guess, swap files</span></span>
<span class="line"><span># can&#39;t be shared by different Redis instances, so make sure to use a swap</span></span>
<span class="line"><span># file for every redis process you are running. Redis will complain if the</span></span>
<span class="line"><span># swap file is already in use.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># Redis交换文件最好的存储是SSD（固态硬盘）</span></span>
<span class="line"><span># 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span></span>
<span class="line"><span># *** WARNING *** if you are using a shared hosting the default of putting</span></span>
<span class="line"><span># the swap file under /tmp is not secure. Create a dir with access granted</span></span>
<span class="line"><span># only to Redis user and configure Redis to create the swap file there.</span></span>
<span class="line"><span>vm-swap-file /tmp/redis.swap</span></span>
<span class="line"><span></span></span>
<span class="line"><span># With vm-max-memory 0 the system will swap everything it can. Not a good</span></span>
<span class="line"><span># default, just specify the max amount of RAM you can in bytes, but it&#39;s</span></span>
<span class="line"><span># better to leave some margin. For instance specify an amount of RAM</span></span>
<span class="line"><span># that&#39;s more or less between 60 and 80% of your free RAM.</span></span>
<span class="line"><span># 将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多少，所有索引数据都是内存存储的（Redis的索引数据就是keys）</span></span>
<span class="line"><span># 也就是说当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为0</span></span>
<span class="line"><span>vm-max-memory 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的。</span></span>
<span class="line"><span># 建议如果存储很多小对象，page大小最后设置为32或64bytes；如果存储很大的对象，则可以使用更大的page，如果不确定，就使用默认值</span></span>
<span class="line"><span>vm-page-size 32</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 设置swap文件中的page数量由于页表（一种表示页面空闲或使用的bitmap）是存放在内存中的，在磁盘上每8个pages将消耗1byte的内存</span></span>
<span class="line"><span># swap空间总容量为 vm-page-size * vm-pages</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># With the default of 32-bytes memory pages and 134217728 pages Redis will</span></span>
<span class="line"><span># use a 4 GB swap file, that will use 16 MB of RAM for the page table.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># It&#39;s better to use the smallest acceptable value for your application,</span></span>
<span class="line"><span># but the default is large in order to work in most conditions.</span></span>
<span class="line"><span>vm-pages 134217728</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Max number of VM I/O threads running at the same time.</span></span>
<span class="line"><span># This threads are used to read/write data from/to swap file, since they</span></span>
<span class="line"><span># also encode and decode objects from disk to memory or the reverse, a bigger</span></span>
<span class="line"><span># number of threads can help with big objects even if they can&#39;t help with</span></span>
<span class="line"><span># I/O itself as the physical device may not be able to couple with many</span></span>
<span class="line"><span># reads/writes operations at the same time.</span></span>
<span class="line"><span># 设置访问swap文件的I/O线程数，最后不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟，默认值为4</span></span>
<span class="line"><span>vm-max-threads 4</span></span>
<span class="line"><span></span></span>
<span class="line"><span>############################### ADVANCED CONFIG ###############################</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Hashes are encoded in a special way (much more memory efficient) when they</span></span>
<span class="line"><span># have at max a given numer of elements, and the biggest element does not</span></span>
<span class="line"><span># exceed a given threshold. You can configure this limits with the following</span></span>
<span class="line"><span># configuration directives.</span></span>
<span class="line"><span># 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span></span>
<span class="line"><span>hash-max-zipmap-entries 512</span></span>
<span class="line"><span>hash-max-zipmap-value 64</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Similarly to hashes, small lists are also encoded in a special way in order</span></span>
<span class="line"><span># to save a lot of space. The special representation is only used when</span></span>
<span class="line"><span># you are under the following limits:</span></span>
<span class="line"><span>list-max-ziplist-entries 512</span></span>
<span class="line"><span>list-max-ziplist-value 64</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Sets have a special encoding in just one case: when a set is composed</span></span>
<span class="line"><span># of just strings that happens to be integers in radix 10 in the range</span></span>
<span class="line"><span># of 64 bit signed integers.</span></span>
<span class="line"><span># The following configuration setting sets the limit in the size of the</span></span>
<span class="line"><span># set in order to use this special memory saving encoding.</span></span>
<span class="line"><span>set-max-intset-entries 512</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Similarly to hashes and lists, sorted sets are also specially encoded in</span></span>
<span class="line"><span># order to save a lot of space. This encoding is only used when the length and</span></span>
<span class="line"><span># elements of a sorted set are below the following limits:</span></span>
<span class="line"><span>zset-max-ziplist-entries 128</span></span>
<span class="line"><span>zset-max-ziplist-value 64</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span></span>
<span class="line"><span># order to help rehashing the main Redis hash table (the one mapping top-level</span></span>
<span class="line"><span># keys to values). The hash table implementation redis uses (see dict.c)</span></span>
<span class="line"><span># performs a lazy rehashing: the more operation you run into an hash table</span></span>
<span class="line"><span># that is rhashing, the more rehashing &quot;steps&quot; are performed, so if the</span></span>
<span class="line"><span># server is idle the rehashing is never complete and some more memory is used</span></span>
<span class="line"><span># by the hash table.</span></span>
<span class="line"><span># </span></span>
<span class="line"><span># The default is to use this millisecond 10 times every second in order to</span></span>
<span class="line"><span># active rehashing the main dictionaries, freeing memory when possible.</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span># If unsure:</span></span>
<span class="line"><span># use &quot;activerehashing no&quot; if you have hard latency requirements and it is</span></span>
<span class="line"><span># not a good thing in your environment that Redis can reply form time to time</span></span>
<span class="line"><span># to queries with 2 milliseconds delay.</span></span>
<span class="line"><span># 指定是否激活重置哈希，默认为开启</span></span>
<span class="line"><span>activerehashing yes</span></span>
<span class="line"><span></span></span>
<span class="line"><span>################################## INCLUDES ###################################</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定包含其他的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各实例又拥有自己的特定配置文件</span></span>
<span class="line"><span># include /path/to/local.conf</span></span>
<span class="line"><span># include /path/to/other.conf</span></span></code></pre></div>`,2)]))}const g=n(l,[["render",i]]);export{m as __pageData,g as default};
